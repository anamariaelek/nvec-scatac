---
title: "Motif syntax"
author: "Anamaria Elek"
date: today
format: 
  html:
    code-fold: false
    code-tools: false
    embed-resources: true
    highlight-style: github
    toc: true 
    code-line-numbers: false 
execute:
  eval: false
  message: false
  warning: false
---

```{r}
#| label: initialize
#| echo: FALSE
knitr::opts_chunk$set(echo = TRUE, fig.width=7, fig.height=5) 
```

In this notebook, we will explore motif syntax.

## Setup

Load packages and functions.

```{r}
#| label: setup

# load in-house functions
source("metacell_downstream_functions/Downstream_functions.R") 
source("metacell_downstream_functions/Gene_module_functions.R")
source("metacell_downstream_functions/utils.R")
source("motif-analysis/mta_downstream_functions.R")
source("scripts/scatac_helper_functions.R")

# global settings
options(stringsAsFactors = FALSE)

# load packages
library(RColorBrewer)
library(BSgenome.jaNemVect1.1.DToL.Assembly)
library(GenomicRanges)
library(data.table)
library(tidyr)
library(stringr)
library(ggplot2)
library(patchwork)
library(ggrepel)
library(ggside)
library(ggseqlogo)
library(universalmotif)
library(grid)
library(ArchR)
library(Seurat)
library(metacell)

# set ggplot2 theme
theme_blank <- theme_minimal() + theme(
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  panel.border = element_blank(),
  panel.grid=element_blank(),
  axis.ticks = element_blank(),
  text = element_text(size=20)
)
theme_py <- theme_light() + theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.border = element_rect(colour = "black", fill = NA),
  text = element_text(size=20),
  strip.placement = "outside", 
  strip.text = element_text(size=20, color="black"),
  strip.background = element_rect(fill="white")
)
theme_set(theme_py)

# helper function to make gene labels
makeGeneLabels <- function(dt) {
  dt[gene_name == "" & common_name != "", gene_name := common_name]
  dt[, gene_label := common_name]
  dt[gene_label == "", gene_label := ifelse(nchar(gene_name) > 45, paste0(substr(gene_name, 1, 43), "..."), gene_name)]
  dt[gene_label == "", gene_label := ifelse(nchar(og) > 45, paste0(substr(og, 1, 43), "..."), og)]
  dt[gene_label == "", gene_label := ifelse(nchar(pfam) > 45, paste0(substr(pfam, 1, 43), "..."), pfam)]
  stopifnot(nrow(dt[gene != "" & gene_label == ""]) == 0)
  return(dt)
}
```

Define directories to read the data from and save the results to.

```{r}
#| label: dirs

adult_dir <- "ArchRProj_Nvec_TSS4_frag200"
gastr_dir <- "ArchRProj_Nvec_gastrula"
pks_dir <- "results/Peaks"
mta_dir <- "results/Motifs"
arc_dir <- "results/Archetypes"
map_dir <- "results/Metacells"
grn_dir <- "results/GRN"
mod_dir <- "results/Modules"
syn_dir <- "results/Syntax"
dir.create(syn_dir, showWarnings = FALSE)
fig_dir <- "plots/Syntax"
dir.create(fig_dir, showWarnings = FALSE)
ann_dir <- "annotation"
```

Load gene annotations.

```{r}
# gene annotation
gnan <- fread(file.path(
  ann_dir, "Nematostella_DToL_FINAL.tsv"
))

# TF annotation
tfan <- fread(file.path(
  ann_dir, "Nematostella_DToL_TFs_FINAL.tsv"
))

# golden markers
gold <- fread(file.path(
  ann_dir, "golden-marks-231124.tsv"
), header = FALSE)
setnames(gold, c("common_name", "gene", "remark"))
```

Project-specific variables:

```{r}
ct_cols <- c(
  "cnidocyte"                  = "#ff42ff",
  "cnidocyte_gastrula"         = "#f7abf7",
  "ecto_pharynx"               = "#5bc0e8",
  "ectoderm"                   = "#51a0be",
  "ecto_aboral"                = "#045170",
  "EMS"                        = "#bdf5bd",
  "EMS_ecto_boundary"          = "#93dbce",
  "gastro_circular_muscle_1"   = "#85c90e",
  "gastro_circular_muscle_2"   = "#73b009",
  "gastro_parietal_muscle"     = "#8ceb10",
  "gastro_IRF1_2"              = "#c1eb05",
  "gastro_somatic_gonad"       = "#bde314",
  "muscle_tentacle_retractor"  = "#ffd700",
  "muscle_mesentery_retractor" = "#f0e229",
  "digestive_filaments_1"      = "#e33d3d",
  "digestive_filaments_2"      = "#d10606",
  "digestive_filaments_3"      = "#ad0303",
  "epidermis_1"                = "#04ccd4",
  "epidermis_2"                = "#16bacc",
  "precursors_PGC"             = "#bebebe",
  "precursors_endoNPC"         = "#8a8686",
  "precursors_NPC"             = "#636363",
  "NPC_1"                      = "#808d91",
  "NPC_2"                      = "#758d92",
  "neuron_GATA_Islet_1"        = "#0c82f7",
  "neuron_GATA_Islet_2"        = "#1175f0",
  "neuron_Pou4_FoxL2_1"        = "#101cde",
  "neuron_Pou4_FoxL2_2"        = "#0b16bf",
  "neuron_Pou4_FoxL2_3"        = "#2e39dd",
  "neuronal_gastrula"          = "#063cb9",
  "gland"                      = "#ff6f08",
  "gland_mucin"                = "#ff8f12"
)
cell_types <- names(ct_cols)
adult_cell_types <- c(
  "cnidocyte",
  "gastro_circular_muscle_1", 
  "gastro_circular_muscle_2",
  "gastro_parietal_muscle",
  "gastro_IRF1_2",
  "gastro_somatic_gonad",
  "muscle_mesentery_retractor",
  "muscle_tentacle_retractor",
  "digestive_filaments_1",
  "digestive_filaments_2",
  "digestive_filaments_3",
  "epidermis_1",
  "epidermis_2",
  "precursors_PGC",
  "precursors_endoNPC",
  "precursors_NPC",
  "neuron_GATA_Islet_1",
  "neuron_GATA_Islet_2",
  "neuron_Pou4_FoxL2_1",
  "neuron_Pou4_FoxL2_2",
  "neuron_Pou4_FoxL2_3",
  "gland"
)
gastr_cell_types <- c(setdiff(cell_types, adult_cell_types))
bct_cols <- toupper(c(
  "cnidocyte"                 = "#ff42ff",
  "ecto"                      = "#51a0be",
  "EMS"                       = "#bdf5bd",
  "gastro_circular_muscle"    = "#73b009",
  "gastro_parietal_muscle"    = "#8ceb10",
  "gastro"                    = "#85c90e",  
  "muscle"                    = "#ffd700",
  "digestive_filaments"       = "#e33d3d",
  "precursors"                = "#bebebe",
  "NPC"                       = "#808d91",
  "epidermis"                 = "#04ccd4",
  "neuron_GATA_Islet"         = "#1175f0",
  "neuron_Pou4_FoxL2"         = "#101cde",
  "neuronal"                  = "#063cb9",
  "gland"                     = "#ff6f08"
))
bct_maps <- setDT(cbind.data.frame(
  cell_type = cell_types,
  broad_cell_type = str_extract(cell_types, paste(names(bct_cols), collapse = "|"))
))
```

## Motif co-occurence

We will derive motif lexicons by starting from motif hits in cell type specific 
peaks. First, get locations of all hits (motif scores above the nth quantile of 
genomic binding energy).

### All peaks

```{r}
# load motif scores
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
q <- 0.95
mta_dt <- rbindlist(lapply(c(
  # archetypes
  file.path(arc_dir, sprintf("motif-scores-archetypes-%s-mona-q%s.tsv.gz", arc_id, q)),
  # experimental motifs
  file.path(mta_dir, sprintf("motif-scores-mona-q%s.tsv.gz", q))
), fread))

# calculate relative motif scores (independent of the motif length)
mta_dt[, relative_motif_score := motif_score / max(motif_score)]
mta_dt <- unique(mta_dt)
```

Get non-overlapping motif hits per peak for each individual motif.

```{r}
# testing dataset
#mta_hits_dt <- mta_dt[motif %in% c("ARCH1635_NEUROG2", "Pou4", "Shox2")]
#mta_hits_dt <- mta_hits_dt[peak %in% mta_hits_dt[order(peak)][, .N, peak][order(-N)][, .SD[1], N]$peak[1:10]]

#' Reduce motif hits to non-overlapping hits for each motif
#' 
#' @param dt dataframe with have individual motif hits in peaks in separate rows, it should have (at least) these columns: seqnames, start, end, motif, motif_score, peak
#' @return dataframe with non-overlapping motif hits
#' 
reduce_ovl_ocurrences <- function(dt) {

  # convert to data.table
  setDT(dt)

  # order data by motif and coordinate
  message(sprintf("%s Ordering %d instances of %d motifs", Sys.time(), nrow(dt), length(unique(dt$motif))))
  dt <- unique(dt[, .(seqnames, start, end, motif, motif_score, peak)])
  setorder(dt, motif, start)

  # identify groups of overlapping motif instances
  .mta_occurr_ovl <- function(dt) {
    message(sprintf("%s Identifying overlapping motif instances, this might take several minutes", Sys.time()))
    dt[, dist := start - lag(end), by = .(motif, peak)]
    dt[is.na(dist), dist := 1000]
    message(sprintf("%s Numbering motif occurrences per peak", Sys.time()))
    dt[, motif_occurrence := cumsum(dist > 0), by = .(motif, peak)]
    # count number of non-overlapping motif hits for individual motifs
    message(sprintf("%s Counting number of motif instances per peak", Sys.time()))
    dt[, motif_count := sum(dist > 0), .(motif, peak)]
  }
  .mta_occurr_ovl(dt)
  message(sprintf("%s Reduced mumber of motif instances to %d", Sys.time(), nrow(dt)))

  # for overlapping motif instances, take the ones with max score
  message(sprintf("%s Selecting motif instances with maximum score", Sys.time()))
  dt[, max_motif_score := max(motif_score), .(motif, peak, motif_occurrence)]
  dt <- dt[motif_score == max_motif_score]
  .mta_occurr_ovl(dt)
  message(sprintf("%s Reduced mumber of motif instances to %d", Sys.time(), nrow(dt)))

  # for motif instances that are still overlapping, 
  # take the coordiantes of maximum possible span
  message(sprintf("%s Selecting maximum span for overlapping instances with max score", Sys.time()))
  dt[, start := min(start), .(motif, peak, motif_occurrence)]
  dt[, end := max(end), .(motif, peak, motif_occurrence)]
  dt[, dist := NULL]
  dt[, max_motif_score := NULL]
  dt <- unique(dt)
  message(sprintf("%s Final number of non-overlapping motif instances: %d", Sys.time(), nrow(dt)))

  return(dt)
}

# mta_novl_hits_dt <- reduce_ovl_ocurrences(mta_hits_dt)
system.time({
  mta_novl_dt <- reduce_ovl_ocurrences(mta_dt)
})
saveRDS(
  mta_novl_dt, 
  file.path(syn_dir, sprintf("motif-hits-novl-%s-mona-q-%s.rds", arc_id, q))
)
```

A function to check co-occurence of pairs of motifs

```{r}
messagetimed <- function(...) {
  message(sprintf("%s %s", Sys.time(), sprintf(...)))
}

count_co_occurrences <- function(dt, min_ovl = NULL) {
  
  # Convert to data.table
  setDT(dt)
  
  # If we don't want to check overlap between pairs of motifs
  # we can use matrix operations to count co-occurrences 
  # (this is much faster!)
  if (is.null(min_ovl)) {

    # Count the number of motif hits in each peak
    mta_hits_dc <- dcast.data.table(dt, peak ~ motif, fun.aggregate = length)
    mta_hits <- as.matrix(mta_hits_dc[, -1])
    rownames(mta_hits) <- mta_hits_dc[[1]]
    
    # Convert to a binary indicator matrix (1 if hit count > 0, otherwise 0)
    mta_hits_ind <- (mta_hits > 0) * 1
    
    # Count co-occurrences of all pairs of motifs using matrix multiplication
    count_matrix <- crossprod(mta_hits_ind)
    
    # Set diagonal to the number of motifs with at least 2 hits
    diag(count_matrix) <- colSums(mta_hits >= 2)
    
    # Return count matrix with motif names
    rownames(count_matrix) <- colnames(count_matrix) <- colnames(mta_hits_ind)
  
  # If we want to check for overlap between every pair of motifs
  # we have to loop through each peak and count pairs of motifs
  } else {

    # Function to check if motifs don't overlap
    motifs_nonoverlap <- function(end1, start2) {
      (end1 - start2) < min_ovl
    }

    # Initialize co-occurrence matrix
    motifs <- unique(dt$motif)
    co_occurrence_matrix <- matrix(
      0,
      nrow = length(motifs), ncol = length(motifs), 
      dimnames = list(motifs, motifs)
    )
    
    # Group data by peak
    grouped_df <- split(dt, by = "peak")

    # Save results to data table
    ds <- data.table()
    
    for (peak in names(grouped_df)) {
      
      message(sprintf(
        "%s Processing %s (%d/%d)", 
        Sys.time(), peak, which(names(grouped_df) == peak), length(names(grouped_df))
      ))
      
      group_df <- grouped_df[[peak]]
      unique_motifs <- unique(group_df$motif)
      ms <- CJ(m1 = unique_motifs, m2 = unique_motifs)[m1 <= m2] 
      
      for (pair in seq_len(nrow(ms))) {

        m1 <- ms$m1[pair]
        m2 <- ms$m2[pair]
        
        # different motifs:
        if (m1 != m2) {

          # filter instances and use vectorized overlap check
          motif1 <- group_df[motif == m1]
          motif2 <- group_df[motif == m2]

          if (nrow(motif1) > 0 & nrow(motif2) > 0) {
            # sort all motif pair instances so that motif1 is always the one with lower start
            m <- CJ(i = seq_len(nrow(motif1)), j = seq_len(nrow(motif2)))
            s <- data.table(
              m1 = motif1$motif_occurrence, m2 = motif2$motif_occurrence,
              m1_start = motif1$start[m$i],
              m2_start = motif2$start[m$j],
              m1_end = motif1$end[m$i],
              m2_end = motif2$end[m$j]
            )
            s[m1_start <= m2_start, ':='(start1 = m1_start, start2 = m2_start, end1 = m1_end, end2 = m2_end)]
            s[m2_start < m1_start, ':='(start1 = m2_start, start2 = m1_start, end1 = m2_end, end2 = m1_end)]
            s[, novl := motifs_nonoverlap(end1, start2)]
            s <- s[, .(novl = all(novl)), .(m1, m2)]
            novl <- any(s$novl)
          } else {
            novl <- FALSE
          }

        # same motifs
        } else {

          motif <- group_df[motif == m1]

          if (nrow(motif) > 1) {
            # sort all motif pair instances so that motif1 is always the one with lower start
            m <- CJ(i = seq_len(nrow(motif)), j = seq_len(nrow(motif)))
            m <- m[i != j]
            s <- data.table(
              m1 = motif$motif_occurrence, m2 = motif$motif_occurrence,
              m1_start = motif$start[m$i],
              m2_start = motif$start[m$j],
              m1_end = motif$end[m$i],
              m2_end = motif$end[m$j]
            )
            s[m1_start <= m2_start, ':='(start1 = m1_start, start2 = m2_start, end1 = m1_end, end2 = m2_end)]
            s[m2_start < m1_start, ':='(start1 = m2_start, start2 = m1_start, end1 = m2_end, end2 = m1_end)]
            s[, novl := motifs_nonoverlap(end1, start2)]
            s <- s[, .(novl = all(novl)), .(m1, m2)]
            novl <- any(s$novl)
          } else {
            novl <- FALSE
          }

        }

        # update matrix
        ms[pair, nonoverlapping := novl]
        if (novl == TRUE) {
          co_occurrence_matrix[m1, m2] <- co_occurrence_matrix[m1, m2] + 1
          co_occurrence_matrix[m2, m1] <- co_occurrence_matrix[m2, m1] + 1
        }

      }
      
      ms[, peak := peak]
      ds <- rbindlist(list(ds, ms), use.names = TRUE, fill = TRUE)
    }
    
  }

  return(list(co_occurrence_matrix, ds))
}
```

Co-occurence without checking for overlaps

```{r}
mta_novl_dt <- readRDS( 
  file.path(syn_dir, sprintf("motif-hits-novl-%s-mona-q-%s.rds", arc_id, q))
)
mta_novl_counts <- count_co_occurrences(mta_novl_dt) # not checking overlap
saveRDS(
  mta_novl_counts, 
  file.path(syn_dir, sprintf("motif-co-occurrences-%s-mona-q-%s.rds", arc_id, q))
)
```

Co-occurence of motifs that don't overlap - this is slow so we run it on peaks split in bins, as a job array on custer.

```{r}
#| label: Co-occurence enrichment binned
#| eval: FALSE

# split peaks in bins
pks <- sort(unique(mta_novl_dt$peak))
pks_list <- sapply(split(pks, ceiling(seq_along(pks) / 1000)), function(x) x)
for (i in seq_along(pks_list)) {
  writeLines(pks_list[[i]], file.path(syn_dir, "bins", sprintf("peaks-%s.txt", i)))
}

# co-occurnece while checking overlap
# run script on bins of peaks (on HPC)
system("./10_Motif_syntax_co-occurrence.sh")
```

Co-occurnece while checking overlap results.

```{r}
# Load results of binned analysis
res_fns <- list.files(file.path(syn_dir, "bins"), pattern = "co-occurrences-.*.rds", full.names = TRUE)
res_lst <- lapply(res_fns, function(x) {
  message(sprintf("(%d/%d) %s", which(res_fns == x), length(res_fns), x))
  readRDS(x)[[2]][nonoverlapping == TRUE]
})
mta_pair_novl_dt <- rbindlist(res_lst)

# Save
saveRDS(
  mta_pair_novl_dt, 
  file.path(syn_dir, sprintf(
    "motif-co-occurrences-nonovl-%s-mona-q-%s.rds", 
    arc_id, q
  ))
)

# Motifs assigned to TFs
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
assign_dt <- fread(file.path(
  "results", "Motifs",
  sprintf("motif-assignment-archetypes-%s.tsv.gz", arc_id)
))
assign_dt <- assign_dt[, .(archetype_name, gene, gene_name, og, common_name, tf_family)]
assign_dt[common_name != "", gene_name := common_name][, common_name := NULL]
assign_dt[gene_name == "", gene_name := ifelse(nchar(og) > 40, paste0(substr(og, 1, 37), "..."), og)][, og := NULL]

# Combine rows for same motif with ,
assign_dt <- assign_dt[, lapply(.SD, paste, collapse = ";"), .SDcols = c("gene", "gene_name", "tf_family"), by = archetype_name]

# Combine with motifs pairs data
setnames(mta_pair_novl_dt, c("m1", "m2"), c("motif1", "motif2"))
setnames(assign_dt, c("motif1", "gene_motif1", "gene_name_motif1", "tf_family_motif1"))
mta_pair_novl_gen_1 <- merge.data.table(
  mta_pair_novl_dt, assign_dt, by = "motif1", allow.cartesian = TRUE
)
setnames(assign_dt, c("motif2", "gene_motif2", "gene_name_motif2", "tf_family_motif2"))
mta_pair_novl_gen <- merge.data.table(
  mta_pair_novl_gen_1, assign_dt, by = "motif2", allow.cartesian = TRUE
)
mta_pair_novl_gen[, gene_pair := sprintf("%s + %s", gene_name_motif1, gene_name_motif2)]

# Save gene annotated non-overlapping co-occurence pairs
saveRDS(
  mta_pair_novl_gen, 
  file.path(syn_dir, sprintf(
    "motif-co-occurrences-nonovl-%s-mona-q-%s-TFs.rds", 
    arc_id, q
  ))
)

# Save co-occurence counts
mta_pair_novl_count_dt <- mta_pair_novl_dt[, .N, .(m1, m2)]
fwrite(
  mta_pair_novl_count_dt, 
  file.path(syn_dir, sprintf(
    "motif-co-occurrences-nonovl-%s-mona-q-%s-counts.tsv.gz", 
    arc_id, q
  ))
)
```

### Per cell type

Co-occurence enrichment in per cell type-specific peaks:
the fraction of peaks with hits of both motif1 and motif2
/ 
fractions of peaks with motif1 hits * fraction of peaks with motif2 hits

```{r}
# Archetype motifs to use
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
q <- 0.95

# Motif counts
mta_novl_dt <- readRDS(
  file.path(syn_dir, sprintf(
    "motif-hits-novl-%s-mona-q-%s.rds", 
    arc_id, q
  ))
)

# Motif pair counts
mta_pair_novl_dt <- readRDS(
  file.path(syn_dir, sprintf(
    "motif-co-occurrences-nonovl-%s-mona-q-%s.rds", 
    arc_id, q
  ))
)

# Motif similarities
sim_mat <- readRDS(
  file.path(mta_dir, "motif-archetypes-all-similarity-PPM-PCC.rds")
)

# All peaks
pks_dt <- fread(file.path(pks_dir, "Peaks_cell_type_mapped.tsv.gz"))

# Peaks per broad cell type
# pks_dt <- fread(file.path(pks_dir, "Peaks_cell_type_mapped_cell_type_assignment.tsv.gz"))

# Where to save the results
lvl <- "broad_cell_type"
cts <- unique(pks_dt[[lvl]])

lvl <- "cell_type"
cts <- names(ct_cols)

lvl <- "cell_type_differential"
cts <- names(ct_cols)

dir.create(file.path(syn_dir, lvl), showWarnings = FALSE)

# Count motif pairs in cell type peaks
for (ct in cts) {

  pks_ct_peaks <- tryCatch({
      
    pks_ct <- fread(file.path(pks_dir, sprintf("Peaks_per_%s_mapped.tsv.gz", lvl)))
    pks_ct_peaks <- pks_ct$peak

  }, error = function(e) {
    warning(sprintf("Error: %s", e$message))
    return(NULL)
  })

  if (!is.null(pks_ct_peaks)) {
    
    # Motif counts in selected peaks
    mta_novl_ct <- mta_novl_dt[peak %in% pks_ct_peaks]
    n_peaks <- length(unique(mta_novl_ct$peak))
    message(sprintf("%d %s peaks", n_peaks, ct))

    # Fraction of peaks with hits to each motif
    mta_novl_ct <- mta_novl_ct[, .(count_peak = length(unique(peak))), by = motif]
    mta_novl_ct[, frac_peak := count_peak / n_peaks, by = motif]
    setorder(mta_novl_ct, -frac_peak)

    # Motif pair counts in selected peaks
    mta_pair_novl_ct <- mta_pair_novl_dt[peak %in% pks_ct_peaks]
    mta_pair_novl_ct <- mta_pair_novl_ct[, .N, .(m1, m2)]
    
    # Fraction of peaks with hits to both motifs
    mta_pair_novl_ct[, frac_peak_pair := N / n_peaks, by = .(m1, m2)]
    setnames(mta_pair_novl_ct, c("m1", "m2", "N"), c("motif1", "motif2", "count_peak_pair"))

    # Add counts for individual motifs
    setnames(
      mta_novl_ct,
      c("motif1", "count_peak_motif1", "frac_peak_motif1")
    )
    mta_pair_novl_ct <- merge.data.table(
      mta_pair_novl_ct, mta_novl_ct, by = "motif1", all.x = TRUE
    )
    setnames(
      mta_novl_ct, 
      c("motif2", "count_peak_motif2", "frac_peak_motif2")
    )
    mta_pair_novl_ct <- merge.data.table(
      mta_pair_novl_ct, mta_novl_ct, by = "motif2", all.x = TRUE
    )
    setorder(mta_pair_novl_ct, -frac_peak_pair)
    setcolorder(mta_pair_novl_ct,c("motif1","motif2"))

    # Compute the enrichment
    mta_pair_novl_ct[, enrichment := frac_peak_pair / (frac_peak_motif1 * frac_peak_motif2), by = .I]

    # For motifs with less than 2 hits, set enrichment to 1
    mta_pair_novl_ct[count_peak_pair <= 2, enrichment := 1]

    # Motif pairs similarity
    mta_pair_novl_ct[, motifs_similarity := sim_mat[motif1, motif2], by = .(motif1, motif2)]

    # Report number of significant pairs
    message(
      sprintf(
        "%d pairs of motifs with enrichment > 2 and fraction of peaks with hits to both motifs > 1%%", 
        nrow(mta_pair_novl_ct[enrichment > 2 & frac_peak_pair > 0.01])
      )
    )
    
    # Save
    fwrite(
      mta_pair_novl_ct, 
      file.path(syn_dir, lvl, sprintf(
        "motif-co-occurrences-enrichment-%s-%s-mona-q-%s.tsv.gz", 
        ct, arc_id, q
      ))
    )
     
  }
}

# Load co-occurence enrichment in all cell types
cts <- names(ct_cols)
enr_dt <- rbindlist(lapply(cts, function(ct) {
  message(ct)
  mta_enr <- fread(
      file.path(syn_dir, lvl, sprintf(
          "motif-co-occurrences-enrichment-%s-%s-mona-q-%s.tsv.gz",
          ct, arc_id, q
      ))
  )
  mta_enr[, cell_type := ct]
}))

# Save all data
saveRDS(
    enr_dt,
    file.path(syn_dir, lvl, sprintf(
        "motif-co-occurrences-enrichment-%s-mona-q-%s.rds",
        arc_id, q
    ))
)

# Annotate
enr_dt[, log_enrichment := log2(enrichment)]
enr_dt[, motif_pair := sprintf("%s + %s", motif1, motif2)]
    
# Add 0s for missing cell types
all_combinations <- CJ(
  motif_pair = unique(enr_dt$motif_pair),
  cell_type = unique(enr_dt$cell_type)
)

# Join with the original data.table
dt <- merge(
  all_combinations, enr_dt,
  by = c("motif_pair", "cell_type"),
  all.x = TRUE
)
dt[is.na(motif1), "motif1" := str_split(motif_pair, " \\+ ")[[1]][1], by = .I]
dt[is.na(motif2), "motif2" := str_split(motif_pair, " \\+ ")[[1]][2], by = .I]
dt[is.na(dt)] <- 0

# Motifs assigned to TFs
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
assign_dt <- fread(file.path(
  "results", "Motifs",
  sprintf("motif-assignment-archetypes-%s.tsv.gz", arc_id)
))

assign_dt <- assign_dt[, .(archetype_name, gene, gene_name, og, common_name, tf_family)]
assign_dt[common_name != "", gene_name := common_name][, common_name := NULL]
assign_dt[gene_name == "", gene_name := ifelse(nchar(og) > 40, paste0(substr(og, 1, 37), "..."), og)][, og := NULL]

# Combine rows for same motif with ,
assign_dt <- assign_dt[, lapply(.SD, paste, collapse = ";"), .SDcols = c("gene", "gene_name", "tf_family"), by = archetype_name]

# Combine with motifs pairs data
setnames(assign_dt, c("motif1", "gene_motif1", "gene_name_motif1", "tf_family_motif1"))
mta_enr_gen <- merge.data.table(dt, assign_dt, by = "motif1", allow.cartesian = TRUE)
setnames(assign_dt, c("motif2", "gene_motif2", "gene_name_motif2", "tf_family_motif2"))
mta_enr_gen <- merge.data.table(mta_enr_gen, assign_dt, by = "motif2", allow.cartesian = TRUE)
mta_enr_gen[, gene_pair := sprintf("%s + %s", gene_name_motif1, gene_name_motif2)]

# save data for shiny app
saveRDS(
  mta_enr_gen, 
  file.path(syn_dir, lvl, "motif-co-occurrences-enrichment.rds")
)
```

Inspect the results

```{r}
# Archetype motifs used
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
q <- 0.95

# Cell type
lvl <- "cell_type"
ct <- "cnidocyte"

# Co-occurence nerichment
mta_enr <- fread(
  file.path(syn_dir, lvl, sprintf(
    "motif-co-occurrences-enrichment-%s-%s-mona-q-%s.tsv.gz", 
    ct, arc_id, q
  ))
)
mta_enr[, log_enrichment := log2(enrichment)]
mta_enr[, motif_pair := sprintf("%s + %s", motif1, motif2)]

# Motifs assigned to TFs
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
assign_dt <- fread(file.path(
  "results", "Motifs",
  sprintf("motif-assignment-archetypes-%s.tsv.gz", arc_id)
))

assign_dt <- assign_dt[, .(archetype_name, gene, gene_name, og, common_name, tf_family)]
assign_dt[common_name != "", gene_name := common_name][, common_name := NULL]
assign_dt[gene_name == "", gene_name := ifelse(nchar(og) > 40, paste0(substr(og, 1, 37), "..."), og)][, og := NULL]

# Combine rows for same motif with ,
assign_dt <- assign_dt[, lapply(.SD, paste, collapse = ";"), .SDcols = c("gene", "gene_name", "tf_family"), by = archetype_name]

# Combine with motifs pairs data
mta_enr_gen <- copy(mta_enr)
setnames(assign_dt, c("motif1", "gene_motif1", "gene_name_motif1", "tf_family_motif1"))
mta_enr_gen <- merge.data.table(mta_enr_gen, assign_dt, by = "motif1", allow.cartesian = TRUE)
setnames(assign_dt, c("motif2", "gene_motif2", "gene_name_motif2", "tf_family_motif2"))
mta_enr_gen <- merge.data.table(mta_enr_gen, assign_dt, by = "motif2", allow.cartesian = TRUE)
mta_enr_gen[, gene_pair := sprintf("%s + %s", gene_name_motif1, gene_name_motif2)]

# Filter pairs to plot
mta_enr_gp <- mta_enr_gen[frac_peak_pair > 0.01]

# Motif logos
# mta_pwm <- read_meme(file.path(mta_dir, "motif-archetypes-all.meme"))
# names(mta_pwm) <- sapply(mta_pwm, function(m) m@name)

# Plot
gp_enr <- ggplot(mta_enr_gp, aes(count_peak_pair, enrichment)) +
  geom_point() +
  #geom_text_repel(
  #  data = mta_enr_gp[(enrichment > 1.25)],
  #  aes(label = gene_pair), max.overlaps = Inf, size = 2
  #) +
  scale_x_continuous(trans = "log10") +
  scale_y_continuous(trans = "log2") +
  labs(
    x = "Peaks with motif co-occurrence",
    y = "Co-occurence enrichment"
  ) +
  theme(
    panel.grid.major = element_line(color = "grey", linewidth = 0.2),
    panel.grid.minor = element_line(color = "grey", linewidth = 0.2)
  )
ggsave(file.path(
  fig_dir, sprintf("motif-co-occurrence-enrichment-%s-%s-mona-q-%s.pdf", ct, arc_id, q)
), gp_enr, width = 14, height = 14)

```

Interactive plotly plot

```{r}
require(ggplot2)
require(plotly)
require(data.table)

# Prepare ggplot
gp_enr <- ggplot(mta_enr_gp, aes(count_peak_pair, enrichment, text = gene_pair)) +
  geom_point(aes(text = sprintf(
    "Gene Pair: %s
    Motif1: %s
    Motif2: %s",
    gene_pair, gene_name_motif1, gene_name_motif2
  ))) +
  scale_x_continuous(trans = "log10") +
  scale_y_continuous(trans = "log2") +
  labs(
    x = "Peaks with motif co-occurrence",
    y = "Co-occurence enrichment"
  ) +
  theme_minimal()

# Convert ggplot to plotly
plotly_enr <- ggplotly(gp_enr, tooltip = "text")

# Save the plotly object as an HTML file
require(htmlwidgets)
html_file <- file.path(fig_dir, sprintf("motif-co-occurrence-enrichment-%s-%s-mona-q-%s.html", ct, arc_id, q))
saveWidget(plotly_enr, file = html_file, selfcontained = TRUE)

```

Plot heatmap of motif pair co-occurnece enrichment in cell types

```{r}
# Filter pairs to plot
enr_mts <- unique(
  mta_enr_gen[frac_peak_pair > 0.025 & enrichment > 2]$motif_pair
)
mta_enr_gp <- mta_enr_gen[motif_pair %in% enr_mts]

# Order pairs
stopifnot(all(mta_enr_gp$cell_type %in% cts))
mta_enr_gp[, cell_type := factor(cell_type, levels = cts)]
mta_enr_gp[order(motif_pair, -enrichment), max_enr_ct := as.integer(.SD[1]$cell_type), motif_pair]
setorder(mta_enr_gp, max_enr_ct, -enrichment, motif_pair)
mta_enr_gp[, motif_pair := factor(motif_pair, levels = unique(mta_enr_gp$motif_pair))]
mta_enr_gp[, gene_pair := factor(gene_pair, levels = unique(mta_enr_gp$gene_pair))]

# Ranges for plotting
mta_enr_gp[, log_enrichment := pmax(log_enrichment, 0)]
mta_enr_gp[, log_enrichment := pmin(log_enrichment, 2)]

# Plot heatmap
gp_enr <- ggplot(mta_enr_gp, aes(cell_type, gene_pair, fill = log_enrichment)) +
  geom_tile() +
  scale_fill_gradient2(
    low = "blue", mid = "white", high = "red", midpoint = 1
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  labs(
    y = sprintf("%s motif pairs", length(unique(mta_enr_gp$gene_pair))),
  )

# Plot tf family annotation bar
mta_ann_gp <- unique(mta_enr_gp[, .(gene_pair, tf_family_motif1, tf_family_motif2)])
mta_ann_gp <- melt.data.table(mta_ann_gp, id.vars = "gene_pair")
mta_ann_gp[, value := paste(unique(str_split(value, ";")[[1]]), collapse = ","), by = .I]
n_fams <- length(unique(mta_ann_gp$value))
custom_palette <- scales::hue_pal()(n_fams)
custom_palette <- colorRampPalette(brewer.pal(12, "Paired"))(n_fams)
gp_fam <- ggplot(mta_ann_gp, aes(variable, gene_pair, fill = value)) +
  geom_tile(width = 1) +
  theme_minimal() +
  scale_fill_manual(values = custom_palette) +
  #scale_fill_viridis_d(option = "C") +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    axis.text.y = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "right",
    legend.box = "vertical"
  ) +
  guides(fill = guide_legend(ncol = 1))

# Combine plot and annotation
require(patchwork)
gp_enr_ann <- gp_enr + gp_fam + plot_layout(ncol = 2, widths = c(10, 1), guides = "collect") 

# Save
ggsave(file.path(
  fig_dir, sprintf("motif-co-occurrence-enrichment-heatmap-%s-mona-q-%s.pdf", arc_id, q)
), gp_enr_ann, width = 7, height = 24)
```

Interactive plot

```{r}
# Plot heatmap
gp_enr <- ggplot(mta_enr_gp, aes(gene_pair, cell_type, fill = log_enrichment)) +
  geom_tile() +
  geom_tile(aes(text = sprintf(
    "Gene Pair: %s
    Cell type: %s
    Enrichment: %.2f",
    gene_pair, cell_type, log_enrichment
  ))) +
  scale_fill_gradient2(
    low = "blue", mid = "white", high = "red", midpoint = 1
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(angle = 90, hjust = 1),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  labs(
    x = sprintf("%s motif pairs", length(unique(mta_enr_gp$gene_pair))),
  )


# Convert ggplot to plotly
plotly_enr <- ggplotly(gp_enr, tooltip = "text")

# Save the plotly object as an HTML file
require(htmlwidgets)
html_file <- file.path(fig_dir, sprintf("motif-co-occurrence-enrichment-heatmap-%s-mona-q-%s.html", arc_id, q))
saveWidget(plotly_enr, file = html_file, selfcontained = TRUE)

# this is messed up
```


## Reduce overlapping motifs (top-down approach, not used)

We will derive motif lexicons by starting from motif hits in all peaks.  
First, get locations of all hits (motif scores above the 95th quantile of 
genomic binding energy) for cell-type enriched motifs. Then we identify groups 
of overlapping motif hits, and select the best scoring motifs as representative 
motif hit per group. 

Load the motifs hits input data.

```{r}
# load motif scores
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
q <- 0.95
mta_dt <- rbindlist(lapply(c(
  # archetypes
  file.path(arc_dir, sprintf("motif-scores-archetypes-%s-mona-q%s.tsv.gz", arc_id, q)),
  # experimental motifs
  file.path(mta_dir, sprintf("motif-scores-mona-q%s.tsv.gz", q))
), fread))

# calculate relative motif scores (independent of the motif length)
mta_dt[, relative_motif_score := motif_score / max(motif_score)]
mta_dt <- unique(mta_dt)

# subset enriched motifs
mta_en <- fread(file.path(mta_dir, "motif-enrichment-mona-q0.98-FC-1-padj-0.001.tsv"))
mta_en[, cell_type := factor(cell_type, levels = cell_types)]
mta_dt <- mta_dt[motif %in% mta_en$archetype_name]

# save input motifs hits
fwrite(
  mta_dt, 
  file.path(syn_dir, "motif-hits-all.tsv.gz"),
  sep = "\t"
)

```

We will reduce sets of overlapping motif hits in peaks to one best scoring 
motif per set. To speed things up, we will run this parallelized across 
chromosomes.

```{bash}
ovl=0.5
mkdir logs

for chr in "NW_026019277.1" "NW_026019278.1" "NW_026019279.1" "NW_026019251.1" "NW_026019260.1" "NW_026019264.1" "NW_026019267.1" "NW_026019271.1" "NW_026019272.1" "NW_026019275.1"
do
Rscript 09_Motif_syntax_top_down.R $chr $ovl > logs/09_Motif_syntax_$chr.log 2>&1 &
done

for chr in "NC_064034.1" "NC_064035.1" "NC_064036.1" "NC_064037.1" "NC_064038.1" "NC_064039.1" "NC_064040.1" "NC_064041.1" "NC_064042.1" "NC_064043.1" "NC_064044.1" "NC_064045.1" "NC_064046.1" "NC_064047.1" "NC_064048.1"
do
Rscript 09_Motif_syntax_top_down.R $chr $ovl > logs/09_Motif_syntax_$chr.log 2>&1 &
done
```

Parse and save results from chromosome iterations.

```{r}
# load results
res_fns <- list.files(
  syn_dir, 
  pattern = "motif-hits-reduced-N[WC].*.rds", 
  full.names = TRUE
)
res_lst <- lapply(res_fns, function(x) readRDS(x))
select_hits_lst <- unlist(lapply(res_lst, function(x) x$select_hits))
reduce_hits_lst <- unlist(lapply(res_lst, function(x) x$reduce_hits))
inputs_hits_lst <- unlist(lapply(res_lst, function(x) x$inputs_hits))

# input motifs hits
inputs_hits <- rbindlist(lapply(inputs_hits_lst, as.data.table))

# save input motifs hits
fwrite(
  inputs_hits, 
  file.path(syn_dir, "motif-hits-all.tsv.gz"),
  sep = "\t"
)

# reduced groups hits list
reduce_hits <- rbindlist(lapply(reduce_hits_lst, as.data.table))

# save reduced groups hits
fwrite(
  reduce_hits, 
  file.path(syn_dir, "motif-hits-reduced.tsv.gz"),
  sep = "\t"
)

# selected motifs hits
select_hits <- rbindlist(lapply(select_hits_lst, as.data.table))

# save selected hits
fwrite(
  select_hits, 
  file.path(syn_dir, "motif-hits-selected.tsv.gz"),
  sep = "\t"
)
```

Plot motif hits for inspection.

```{r}
# plot motif hits for inspection
p_gr_all <- do.call("c", inputs_hits_lst)
p_gr_sel <- do.call("c", select_hits_lst)
pks <- intersect(unique(p_gr_all$peak), unique(p_gr_sel$peak))

# # randomly subset peaks because there's just too many
# set.seed(1950)
# pks <- sample(pks, 10)
# pks <- c(
#   "peak111660", "peak111529", "peak110544", "peak109265", "peak107739",
#   "peak108885", "peak107214", "peak110551", "peak112033", "peak109951"
# )

# check peaks with top scores of enriched motifs
pks_mt <- unique(mta_en[fc > 2 & padj < 1e-5][,.(cell_type, archetype_name)])[order(cell_type)]
pks_gm <- p_gr_all[p_gr_all$motif %in% pks_mt[cell_type=="cnidocyte"]$archetype_name]
pks_dm <- as.data.table(pks_gm)
setorder(pks_dm, -relative_motif_score)
mtn <- "ARCH56_POU4F1"
pks <- unique(pks_dm[motif == mtn]$peak)
if (length(pks) > 20) {
  pks <- sample(pks, 20)
}

# where to save the results
plot_hits_lst <- vector("list", length(pks)); names(plot_hits_lst) <- pks
for (pk in pks) {
  
  # all motif hits
  pgr_all <- p_gr_all[p_gr_all$peak == pk]
  gpp_all <- mta_plot_granges(
    pgr_all, 
    label = "motif", 
    color = "relative_motif_score"
  ) +
    labs(title = "Input motif hits") +
    theme(
      axis.text.x = element_blank(),
      axis.title.x = element_blank()
    )
  # reduced motif hits
  pgr_sel <- p_gr_sel[p_gr_sel$peak == pk]
  gpp_sel <- mta_plot_granges(
    pgr_sel, 
    label = "motif", 
    color = "relative_motif_score",
    xlims = c(min(start(pgr_all)), max(end(pgr_all)))
  ) + 
    labs(title = "Non-overlapping motif hits")
  # assemble the plots
  gpp <- gpp_all / gpp_sel + 
    plot_layout(ncol = 1, guides = "keep") +
    plot_annotation(title = sprintf("%s (%s)", pk, mtn))
  # add to plots list
  plot_hits_lst[[pk]] <- gpp
}

# save plots
pdf(
  file.path(fig_dir, "motif-hits-ranges-reduced.pdf"), 
  width = 24, height = 18
)
print(plot_hits_lst)
dev.off()

```

Per cell type lexicons: merge cell type specific peaks with reduced hits info.

```{r}
# load motifs hits
select_hits <- fread(file.path(syn_dir, "motif-hits-selected.tsv.gz"))
select_hits[, strand := NULL]
setnames(
  select_hits, 
  c("seqnames", "start", "end", "width"),
  c("motif_seqnames", "motif_start", "motif_end", "motif_width")
)

# all peaks
peaks <- fread(file.path(pks_dir, "Peaks_cell_type_mapped.bed"))
setnames(peaks, c("seqnames", "start", "end", "peak", "score", "strand"))
peaks <- unique(peaks)
peaks_gr <- makeGRangesFromDataFrame(peaks, keep.extra.columns = TRUE)

  
# load per cell type peaks
pks_list <- vector("list", length = length(cell_types))
names(pks_list) <- cell_types
for (ct in cell_types) {

  message(sprintf("Peaks for %s", ct))
  
  # cell type peaks
  stg_dir <- ifelse(ct %in% adult_cell_types, adult_dir, gastr_dir)
  pks_fn <- file.path(
    stg_dir, "ArchRProj", "PeakDifferential", "cell_type_filtered",
    sprintf("Peaks-%s-vs-others.tsv", ct)
  )
  pks_dt <- fread(pks_fn, select = 1:3)
  setnames(pks_dt, c("seqnames", "start", "end"))
  
  pks_gr <- makeGRangesFromDataFrame(pks_dt)
  
  # overlp peaks (to map per-stage peak ids to final peak set ids)
  pks_ovl <- findOverlaps(query = peaks_gr, subject = pks_gr)
  pks_dat <- peaks_gr[queryHits(pks_ovl)]
  
  # add to list
  pks_list[[ct]] <- as.data.table(pks_dat)

}
pks_ct <- rbindlist(pks_list, idcol = "cell_type")
pks_ct[, c("score", "strand") := NULL]

# merge with selected motif hits
stopifnot(all(unique(pks_ct$peak) %in% select_hits$peak))
mts_ct <- merge(
  pks_ct, select_hits, 
  by = "peak", 
  allow.cartesian = TRUE
)

# save
fwrite(
  mts_ct, 
  file.path(syn_dir, "motif-hits-selected-cell-type.tsv.gz"),
  sep = "\t"
)
```

Add motifs similarity clusters info to motifs hits

```{r}
# archetype pairwise similarities
sim_mat <- readRDS(
  file.path(arc_dir, "motif-similarity-archetypes-PPM-PCC-0.8-IC0.5-5bp.rds")
)

# clusters of archetypes based on pairwise similarities
hc <- hclust(
  tgs_dist(sim_mat), method = "complete"
)
ord <- hc$labels[hc$order]
sim_mat <- sim_mat[ord, ord]
k <- 400
ctr <- cutree(hc, k = k)

# add experimental motifs
ets <- unique(mts_ct[!motif %in% names(ctr)]$motif)
ctr <- c(ctr, structure(
  max(ctr) + seq_along(ets),
  names = ets
))

# add to motif hits info
mts_ct[, motif_cluster := ctr[motif]]
stopifnot(nrow(mts_ct[is.na(motif_cluster)])==0)

# save
fwrite(
  mts_ct, 
  file.path(syn_dir, "motif-hits-selected-cell-type.tsv.gz"),
  sep = "\t"
)
```

## Reduce overlapping motifs (bottom-up approach)

We will derive motif lexicons by starting from motif hits in cell type specific 
peaks. First, get locations of all hits (motif scores above the nth quantile of 
genomic binding energy) for cell-type enriched motifs. Then we identify groups 
of overlapping motif hits, and select the most enriched motif as representative 
motif hit per group. 

Load the motifs hits input data.

```{r}
# load motif scores
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
q <- 0.8
mta_dt <- rbindlist(lapply(c(
  # archetypes
  file.path(arc_dir, sprintf("motif-scores-archetypes-%s-mona-q%s.tsv.gz", arc_id, q)),
  # experimental motifs
  file.path(mta_dir, sprintf("motif-scores-mona-q%s.tsv.gz", q))
), fread))

# calculate relative motif scores (independent of the motif length)
mta_dt[, relative_motif_score := motif_score / max(motif_score)]
mta_dt <- unique(mta_dt)

# subset enriched motifs
mta_en <- rbindlist(lapply(c(
  # archetypes
  file.path(arc_dir, sprintf("motif-enrichment-cell-type-archetypes-%s-mona-q0.98.tsv.gz", arc_id)),
  # experimental motifs
  file.path(mta_dir, "motif-enrichment-mona-q0.98-FC-1-padj-0.001.tsv.gz")
), function(fn) {
  dt <- fread(fn)
  if ("motif" %in% colnames(dt)) setnames(dt, "motif", "archetype_name")
  cols <- c("archetype_name", "cell_type", "fc", "pval", "padj", "f_fg", "f_bg", "n_fg", "n_bg")
  dt[, ..cols]
}), use.names = TRUE, fill = TRUE)
mta_en[, cell_type := factor(cell_type, levels = cell_types)]
mta_en <- unique(mta_en[,.(cell_type, archetype_name, fc, pval, padj)])
setnames(mta_en, "archetype_name", "motif")
mta_dt <- mta_dt[motif %in% mta_en$motif]

# save input motifs hits
bed_cols <- c("seqnames", "start", "end", "motif", "relative_motif_score", "strand")
fwrite(
  mta_dt[,..bed_cols], 
  file.path(syn_dir, "motif-hits-all.bed.gz"),
  col.names = FALSE,
  sep = "\t"
)
# fwrite(
#   mta_dt, 
#   file.path(syn_dir, "motif-hits-all.tsv.gz"),
#   sep = "\t"
# )

# # peaks with high (>0.1) in silico chip score
# ics_fn <- file.path(syn_dir, "motif-hits-ics-filtered.tsv.gz")
# # if filtered peaks file doesn't exist, create it
# if (!file.exists(ics_fn)) {
#   message("Filtering motif hits by in silico ChIP score")
#   lvl <- "metacell"
#   id <- "genes_exp_FC2_acc_FC4_spearman"
#   thr <- 0.1
#   ics_dt <- fread(file.path(
#     grn_dir, lvl, sprintf(
#       "insilico-chip-binding-score-%s.tsv.gz", id
#     )
#   ))
#   ics_dt <- unique(ics_dt[in_silico_chip_score > thr, .(seqnames, start, end, peak, motif)])
#   fwrite(ics_dt, file.path(syn_dir, "motif-hits-ics-filtered.tsv.gz"), sep = "\t")
# } else {
#   message("Loading filtered motif hits: ", ics_fn)
#   ics_dt <- fread(ics_fn, sep = "\t")
# }
# 
# # filter peaks with motif hits by in silico chip score
# mta_dt <- merge.data.table(mta_dt, ics_dt[, .(peak, motif)], by = c("peak", "motif"))
# mta_dt <- unique(mta_dt)

# add gene-motif assignment info
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
arc_as <- fread(file.path(mta_dir, sprintf(
  "motif-assignment-archetypes-%s.tsv.gz", arc_id
)))
setnames(arc_as, "archetype_name", "motif")
mta_dt <- merge.data.table(
  mta_dt, 
  rbindlist(list(
    unique(arc_as[, .(motif, gene, gene_name, common_name, og, pfam)]),
    gnan[common_name=="FoxQ2d", .(gene, gene_name, common_name, og, pfam)][, motif := "FoxQ2d"]
  ), use.names=TRUE), 
  by = "motif",
  all.x = TRUE, sort = FALSE, allow.cartesian = TRUE
)
stopifnot(nrow(mta_dt[is.na(gene)]) == 0)

# save filtered motifs hits
bed_cols <- c("seqnames", "start", "end", "gene", "relative_motif_score", "strand", "motif", "gene_name", "common_name", "og", "pfam")
fwrite(
  mta_dt[,..bed_cols], 
  file.path(syn_dir, "motif-hits-ics.bed.gz"),
  col.names = FALSE,
  sep = "\t"
)
```

For each cell type, get specific peaks and reduce overlapping motifs in each 
peak, selecting the top enriched one per group.

```{r}
# all peaks
peaks <- fread(file.path(pks_dir, "Peaks_cell_type_mapped.bed"))
setnames(peaks, c("seqnames", "start", "end", "peak", "score", "strand"))
peaks <- unique(peaks)
peaks_gr <- makeGRangesFromDataFrame(peaks, keep.extra.columns = TRUE)

# overlap to merge peaks
reciprocal_overlap <- 0.5

# load per cell type peaks
pks_list <- 
  select_hits_list <- 
    reduce_hits_list <-
      inputs_hits_list <- 
        vector("list", length = length(cell_types))
names(pks_list) <- 
  names(select_hits_list) <- 
    names(reduce_hits_list) <- 
      names(inputs_hits_list) <- 
        cell_types

for (ct in cell_types) {

  message(sprintf("%s | Reducingp peaks for %s", Sys.time(), ct))
  
  # cell type peaks
  stg_dir <- ifelse(ct %in% adult_cell_types, adult_dir, gastr_dir)
  pks_fn <- file.path(
    stg_dir, "ArchRProj", "PeakDifferential", "cell_type_filtered",
    sprintf("Peaks-%s-vs-others.tsv", ct)
  )
  pks_dt <- fread(pks_fn, select = 1:3)
  setnames(pks_dt, c("seqnames", "start", "end"))
  
  pks_gr <- makeGRangesFromDataFrame(pks_dt)
  
  # overlap peaks (to map per-stage peak ids to final peak set ids)
  pks_ovl <- findOverlaps(query = peaks_gr, subject = pks_gr)
  pks_dat <- peaks_gr[queryHits(pks_ovl)]
  
  # add to list
  pks_list[[ct]] <- pks_dat
  
  # peaks in cell type
  mta_ct_dt <- mta_dt[peak %in% pks_dat$peak]
  
  # motif enrichment in cell type
  mta_ct_en <- mta_en[cell_type == ct]
  
  # combine
  mta_ct <- merge.data.table(mta_ct_dt, mta_ct_en, by = "motif", all.x = TRUE)
  
  # make ranges
  mta_gr <- makeGRangesFromDataFrame(mta_ct, keep.extra.columns = TRUE)
  
  # reduce motif hits
  red_res <- mta_reduce_motif_hits(
    mta_gr, 
    reciprocal_overlap = reciprocal_overlap,
    order_col = "padj",
    order_decrease = FALSE
  )
  
  # add to list
  select_hits_list[[ct]] <- red_res$select_hits
  reduce_hits_list[[ct]] <- red_res$reduce_hits
  inputs_hits_list[[ct]] <- red_res$inputs_hits
  
}

message(sprintf("%s | All done", Sys.time()))

# save input motifs hits
inputs_hits <- do.call("c", unname(inputs_hits_list))
inputs_hits <- as.data.table(inputs_hits)
fwrite(
  inputs_hits, 
  file.path(syn_dir, "motif-hits-all.tsv.gz"),
  sep = "\t"
)

# save reduced groups hits
reduce_hits <- do.call("c", unname(reduce_hits_list))
reduce_hits <- as.data.table(reduce_hits)
fwrite(
  reduce_hits, 
  file.path(syn_dir, "motif-hits-reduced.tsv.gz"),
  sep = "\t"
)

# save selected motifs hits
select_hits <- do.call("c", unname(select_hits_list))
select_hits <- as.data.table(select_hits)
fwrite(
  select_hits, 
  file.path(syn_dir, "motif-hits-selected.tsv.gz"),
  sep = "\t"
)
```

To speed things up, we will run this parallelized across cell types.

```{bash}
ovl=0.5
q=0.8
sub="active" # enrich OR enrich-assign OR active
mkdir logs
for ct in cnidocyte cnidocyte_gastrula ectoderm ecto_aboral EMS EMS_ecto_boundary ecto_pharynx gastro_circular_muscle_1 gastro_circular_muscle_2 gastro_parietal_muscle gastro_IRF1_2 gastro_somatic_gonad muscle_tentacle_retractor muscle_mesentery_retractor digestive_filaments_1 digestive_filaments_2 digestive_filaments_3 epidermis_1 epidermis_2 precursors_PGC precursors_endoNPC precursors_NPC NPC_1 NPC_2 neuron_GATA_Islet_1 neuron_GATA_Islet_2 neuron_Pou4_FoxL2_1 neuron_Pou4_FoxL2_2 neuron_Pou4_FoxL2_3 neuronal_gastrula gland gland_mucin
do
Rscript 09_Motif_syntax_bottom_up.R $ct $ovl $q $sub > logs/09_Motif_syntax_$ct.log 2>&1 &
done
```

Parse and save results from cell type iterations.

```{r}
# load results
syn_sub_dir <- "q0.8-hits-active-motifs-ovl-0.5"
res_fns <- list.files(
  file.path(syn_dir, syn_sub_dir),
  pattern = "motif-hits-reduced-.*.rds", 
  full.names = TRUE
)
res_lst <- lapply(res_fns, function(x) readRDS(x))
select_hits_lst <- unlist(lapply(res_lst, function(x) x$select_hits))
reduce_hits_lst <- unlist(lapply(res_lst, function(x) x$reduce_hits))
inputs_hits_lst <- unlist(lapply(res_lst, function(x) x$inputs_hits))

# input motifs hits
inputs_hits <- rbindlist(lapply(inputs_hits_lst, as.data.table))

# save input motifs hits
fwrite(
  inputs_hits, 
  file.path(syn_dir, syn_sub_dir, "motif-hits-all.tsv.gz"),
  sep = "\t"
)

# reduced groups hits list
reduce_hits <- rbindlist(lapply(reduce_hits_lst, as.data.table))

# save reduced groups hits
fwrite(
  reduce_hits, 
  file.path(syn_dir, syn_sub_dir, "motif-hits-reduced.tsv.gz"),
  sep = "\t"
)

# selected motifs hits
select_hits <- rbindlist(lapply(select_hits_lst, as.data.table))

# save selected hits
fwrite(
  select_hits, 
  file.path(syn_dir, syn_sub_dir, "motif-hits-selected.tsv.gz"),
  sep = "\t"
)
```

Plot motif hits for inspection.

```{r}
# peaks per cell type
pks_list <- vector("list", length = length(cell_types))
for (ct in cell_types) {

  # cell type peaks
  stg_dir <- ifelse(ct %in% adult_cell_types, adult_dir, gastr_dir)
  pks_fn <- file.path(
    stg_dir, "ArchRProj", "PeakDifferential", "cell_type_filtered",
    sprintf("Peaks-%s-vs-others.tsv", ct)
  )
  pks_dt <- fread(pks_fn, select = 1:3)
  setnames(pks_dt, c("seqnames", "start", "end"))
  
  pks_gr <- makeGRangesFromDataFrame(pks_dt)
  
  # overlap peaks (to map per-stage peak ids to final peak set ids)
  pks_ovl <- findOverlaps(query = peaks_gr, subject = pks_gr)
  pks_dat <- peaks_gr[queryHits(pks_ovl)]
  
  message(sprintf("%s peaks for %s", length(unique(pks_dat$peak)), ct))
  
  # add to list
  pks_list[[ct]] <- as.data.table(pks_dat)
  
}

# randomly subset peaks because there's just too many
pks_sub_list <- sapply(names(pks_list), function(ct) {
  pks <- unique(pks_list[[ct]]$peak)
  if (length(pks) > 10) {
    set.seed(1950)
    pks <- sample(pks, 10)
  }
  return(pks)
}, simplify = FALSE, USE.NAMES = TRUE)

# reduced motif hits results
syn_sub_dir <- "q0.8-hits-enrich-assign-motifs-ovl-0.5"
inputs_hits <- fread(file.path(syn_dir, syn_sub_dir, "motif-hits-all.tsv.gz"))
select_hits <- fread(file.path(syn_dir, syn_sub_dir, "motif-hits-selected.tsv.gz"))


# list to save the plots
plot_hits_lst <- vector("list", length = length(cell_types))
names(plot_hits_lst) <- cell_types

for (ct in cell_types) {
  
  p_gr_all <- inputs_hits[inputs_hits$cell_type == ct, ]
  p_gr_sel <- select_hits[select_hits$cell_type == ct, ]
  
  # peaks to plot
  pks <- pks_sub_list[[ct]]
  
  # where to save the results
  plot_hits_lst[[ct]] <- vector("list", length(pks))
  names(plot_hits_lst[[ct]]) <- pks
  
  for (pk in pks) {
    
    # all motif hits
    pgr_all <- p_gr_all[p_gr_all$peak == pk]
    gpp_all <- mta_plot_granges(
      pgr_all, 
      label = "motif", 
      color = "fc"
    ) +
      labs(title = "Input motif hits") +
      theme(
        axis.text.x = element_blank(),
        axis.title.x = element_blank()
      )
    # reduced motif hits
    pgr_sel <- p_gr_sel[p_gr_sel$peak == pk]
    gpp_sel <- mta_plot_granges(
      pgr_sel, 
      label = "motif", 
      color = "fc",
      xlims = c(min(pgr_all$start), max(pgr_all$end))
    ) + 
      labs(title = "Non-overlapping motif hits")
    # assemble the plots
    gpp <- gpp_all / gpp_sel + 
      plot_layout(ncol = 1, guides = "keep") +
      plot_annotation(title = sprintf("%s %s", ct, pk))
    # add to plots list
    plot_hits_lst[[ct]][[pk]] <- gpp
  }
}


# save plots
pdf(
  file.path(fig_dir, sprintf("motif-hits-ranges-reduced-%s.pdf", syn_sub_dir)), 
  width = 24, height = 18
)
print(plot_hits_lst)
dev.off()

```

## Comparisons

### Parse data for comparisons

```{r}
# results to compare
syn_sub_dirs <- c(
  "0.80 enrich" = "q0.8-hits-enrich-assign-motifs-ovl-0.5",
  "0.90 enrich" = "q0.9-hits-enrich-assign-motifs-ovl-0.5",
  "0.95 enrich" = "q0.95-hits-enrich-assign-motifs-ovl-0.5",
  "0.80 active" = "q0.8-hits-active-motifs-ovl-0.5",
  "0.90 active" = "q0.9-hits-active-motifs-ovl-0.5",
  "0.95 active" = "q0.95-hits-active-motifs-ovl-0.5"
)

# load results
mts_ct <- rbindlist(sapply(syn_sub_dirs, function(x) {
  fread(file.path(syn_dir, x, "motif-hits-selected.tsv.gz"))[, iteration := x]
}, simplify = FALSE, USE.NAMES = TRUE), fill = TRUE)
mts_ct[, cell_type := factor(cell_type, levels = cell_types)]
```

Count occurrences for combinations of motifs.

```{r}
# # # # # # # # # # # # #
#  motifs hits results  #
# # # # # # # # # # # # #

# reduced motif hits
mts_ct[, archetype_name := motif]

# # # # # # # # # # # # # #
#  peaks classification   #
# # # # # # # # # # # # # #

# all peaks
pks_al <- fread(file.path(pks_dir, "Peaks_cell_type_mapped.tsv"))

# load peaks classification
pks_dt <- fread(file.path(pks_dir, "Peaks_cell_type_promoter_annotation.tsv"))

# cell type entries into separate rows
pks_dt <- separate_rows(pks_dt, "cell_types", sep = ",")
setDT(pks_dt)
setnames(pks_dt, "cell_types", "cell_type")

# annotations for each peak: CP > SP > AP > NO
pks_dt <- unique(pks_dt[, .(peak, promoter, cell_type)])
pks_dt[promoter == "AP+", promoter := "AP"]
pks_dt[, promoter := factor(promoter, levels = c("CP", "SP", "AP", "NO"))]
setorder(pks_dt, peak, promoter)
setnames(pks_dt, "cell_type", "broad_cell_type")
pks_dt <- pks_dt[, .SD[1], .(peak, broad_cell_type)]
pks_dt <- unique(pks_dt)
stopifnot(!any(pks_dt[,.N,.(peak, broad_cell_type)]$N > 1))

# merge hits results with peaks classification
mts_ct <- merge.data.table(
  mts_ct, bct_maps,
  by = "cell_type", all.x = TRUE
)
mts_ct <- merge.data.table(
  mts_ct, pks_dt,
  by = c("peak", "broad_cell_type"), 
  all.x = TRUE
)
mts_ct[is.na(promoter), promoter := "NO"]

# # # # # # # # # # # #
#  archetype family   #
# # # # # # # # # # # #

# load archetype family info
cor_dt <- fread(file.path(
  "Results", 
  sprintf("ChromVAR-%s", arc_id), 
  "correlation-seacells-archetype-motif-score-gene.tsv.gz"
))

# add archetype family info
mts_ct <- merge.data.table(
  mts_ct, 
  unique(cor_dt[, .(archetype_name, archetype_family)]),
  by = "archetype_name",
  sort = FALSE, all.x = TRUE
)
mts_ct[archetype_name == "FoxQ2d", archetype_family := "Forkhead"]

# # # # # # # # # # # # # # #
#  motif to TF assignment   #
# # # # # # # # # # # # # # #

# load motif-to-TF assignments
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
arc_as <- fread(file.path(arc_dir, sprintf(
  "motif-assignment-archetypes-%s.tsv", arc_id
)))

# merge hits results with motif assignments
mts_ct <- merge.data.table(
  mts_ct, unique(arc_as[, .(
    gene, gene_name, common_name, og, pfam, tf_family, 
    archetype_name, CisBP_assignment
  )]),
  by = c("archetype_name"),
  all.x = TRUE, sort = FALSE, allow.cartesian = TRUE
)
mts_ct[is.na(mts_ct)] <- ""

# make gene labels
mts_ct <- makeGeneLabels(mts_ct)

# # # # # # # # #
#  active TFs   #
# # # # # # # # #

# subset motifs assigned to active TFs?
use_active_tfs <- FALSE

if (use_active_tfs == TRUE) {
  
  # load active TFs
  grn_tfs <- fread(file.path(
    grn_dir, 
    "networks", 
    "grn_tfs_info_expression_fc_0.4_accessibility_access_0.4_chromvar_4.tsv"
  ))
  grn_tfs <- unique(grn_tfs[,.(motif, gene, zscore, cell_type)])
  
  # merge hits results with active TFs
  mts_ct <- merge.data.table(
    mts_ct, grn_tfs,
    by = c("motif", "gene", "cell_type"),
    all = FALSE, sort = FALSE
  )
  
}

# # # # # # # # # #
#   count hits    #
# # # # # # # # # #

# count motif hits per cell type
mts_ct[, cell_type := factor(cell_type, levels = cell_types)]
mts_ct[, n_peaks := length(unique(.SD$peak)), .(cell_type, iteration)]
mts_ct[, n_peaks_motif := length(unique(.SD$peak)), .(cell_type, archetype_name, iteration)]
mts_ct[, frac_peaks_motif := n_peaks_motif / n_peaks]

# list to save results
cmb_ls <- structure(vector("list", length = length(syn_sub_dirs)), names = syn_sub_dirs)
cmb_ls <- sapply(cmb_ls, function(x) structure(vector("list", length = length(cell_types)), names = cell_types), simplify = FALSE, USE.NAMES = TRUE)

# loop over cell types
require(pbapply)

pks_fcs_thr <- 1.5
pks_fdr_thr <- 0.01
if (!is.null(pks_fcs_thr) & !is.null(pks_fdr_thr)) {
  syn_fn <- sprintf(
    "motif-hits-combinations-in-peaks-FC-%s-FDR-%s.tsv.gz", 
    pks_fcs_thr, pks_fdr_thr
  )
} else if (is.null(pks_fcs_thr) & !is.null(pks_fcs_thr)) {
  syn_fn <- sprintf(
    "motif-hits-combinations-in-peaks-FDR-%s.tsv.gz", 
    pks_fdr_thr
  )
} else if (!is.null(pks_fcs_thr) & is.null(pks_fdr_thr)) {
  syn_fn <- sprintf(
    "motif-hits-combinations-in-peaks-FC-%s.tsv.gz", 
    pks_fcs_thr
  )
} else {
  syn_fn <- "motif-hits-combinations-in-peaks.tsv.gz"
}

for (it in syn_sub_dirs) {
  
  # use genes names instead of motifs 
  use_genes_assigned_to_motfs <- switch(
    it,
    "q0.8-hits-enrich-assign-motifs-ovl-0.5" = FALSE,
    "q0.9-hits-enrich-assign-motifs-ovl-0.5" = FALSE,
    "q0.95-hits-enrich-assign-motifs-ovl-0.5" = FALSE,
    "q0.8-hits-active-motifs-ovl-0.5" = TRUE,
    "q0.9-hits-active-motifs-ovl-0.5" = TRUE,
    "q0.95-hits-active-motifs-ovl-0.5" = TRUE
  )
  
  for (ct in cell_types) {
    
    message(ct)
    cols <- c("N", "peak", "promoter", "motif", "motif_occur", "motif_enh_occur")
    
    # make a matrix of motif hits in peaks
    if (use_genes_assigned_to_motfs == TRUE) {
      mts_dat <- unique(
        mts_ct[iteration == it & cell_type == ct & gene != "", .(
          cell_type, peak, promoter, motif,
          # motif_start, motif_end,  # include if we want all instances of motif in a peak
          gene, gene_label, common_name
        )]
      )
    } else {
      mts_dat <- unique(
        mts_ct[iteration == it & cell_type == ct, .(
          cell_type, peak, promoter, motif
          # motif_start, motif_end,  # include if we want all instances of motif in a peak
        )]
      )
    }
    
    # add peaks diff values
    pks_df <- fread(file.path(
      ifelse(ct %in% adult_cell_types, adult_dir, gastr_dir), 
      "ArchRProj", "PeakDifferential", "cell_type_filtered", 
      sprintf("Peaks-%s-vs-others.tsv", ct)
    ))
    setnames(pks_df, "peak", ifelse(ct %in% adult_cell_types, "peak_adult", "peak_gastrula"))
    pks_df <- merge.data.table(
      pks_df, pks_al[, .(seqnames, start, end, peak, peak_adult, peak_gastrula)],
      by = c("seqnames", "start", "end", ifelse(ct %in% adult_cell_types, "peak_adult", "peak_gastrula")),
      all.x = FALSE, sort = FALSE
    )
    pks_df[, c("peak_adult", "peak_gastrula", "score", "strand") := NULL]
    pks_df <- unique(pks_df)
    mts_dat <- merge.data.table(
      mts_dat, pks_df, by = "peak", all.x = TRUE, sort = FALSE
    )
    setcolorder(mts_dat, c(
      "cell_type", "motif", "peak", "promoter", 
      "seqnames", "start", "end", "Log2FC", "Pval", "FDR"
    ))
    
    # subset peaks
    if (!is.null(pks_fcs_thr) & !is.null(pks_fdr_thr)) {
      mts_dat <- mts_dat[Log2FC > pks_fcs_thr & FDR < pks_fdr_thr]
    } else if (is.null(pks_fcs_thr) & !is.null(pks_fcs_thr)) {
      mts_dat <- mts_dat[Log2FC > pks_fcs_thr]
    } else if (!is.null(pks_fcs_thr) & is.null(pks_fdr_thr)) {
      mts_dat <- mts_dat[FDR < pks_fdr_thr]
    }
      
    # number of peaks in cell type
    n_pks <- length(unique(mts_dat$peak))
    n_enh_pks <- length(unique(mts_dat[promoter == "NO"]$peak))
    
    # count in how many peaks a motif occurs
    occ_mts <- unique(
      mts_dat[, .(peak, promoter, motif)]
    )[, ':='(
      motif_occur = length(unique(.SD$peak)),
      motif_enh_occur = length(unique(.SD[promoter == "NO"]$peak))
    ), motif]
    occ_mts <- unique(occ_mts[, .(motif, motif_occur, motif_enh_occur)])
    
    # add to motifs hits table
    mts_dat <- merge.data.table(
      mts_dat, occ_mts, by = "motif", 
      all.x = TRUE, sort = FALSE
    )
    
    # genes instead of motifs
    if (use_genes_assigned_to_motfs == TRUE) {
      mts_dat[, genes := paste(unique(sort(.SD$gene)), collapse = " | "), .(motif)]
      mts_dat[, gene_label := paste(unique(c(
        sort(.SD[common_name != ""]$gene_label),
        sort(.SD[common_name == ""]$gene_label)
      )), collapse = " | "), .(motif)]
      mts_dat[nchar(gene_label) > 100, gene_label := paste0(
        substr(gene_label, 1, 97), "..."
      ), gene_label]
      mts_dat[, c("gene") := NULL]
      mts_dat <- unique(mts_dat)
      mts_dat[, motif := NULL]
      setnames(mts_dat, "gene_label", "motif")
    }
    
    # select motifs that have hits in more than 10% of peaks
    mts_top <- mts_dat[motif_occur > 0.1 * length(unique(mts_dat$peak))]
    mts_top[, N := 1]
    mts_top <- unique(mts_top[, ..cols])
    
    # find top combinations of motifs
    mts_com <- rbindlist(lapply(c(2:4), function(n) {
      tryCatch({
        message("Counting combinations of ", n, " motifs in ", ct, " peaks:")
        mts_comb <- combn(
          unique(mts_top$motif), n, simplify = FALSE
        )
        rbindlist(pblapply(mts_comb, function(x) {
          dt <- unique(mts_top[motif %in% x, .(peak, promoter, motif)])[, N := .N, peak]
          unique(dt[N == n][, motif := paste(x, collapse = " + ")])
        }))      
      }, error = function(e) NULL)
    }))
    
    # count in how many peaks a combination of motif occurs
    if (nrow(mts_com) > 0) { 
      mts_com[, ':='(
        motif_occur = length(unique(.SD$peak)),
        motif_enh_occur = length(unique(.SD[promoter == "NO"]$peak))
      ), .(motif, N)]
      
      # combine with motifs hits table
      mts_top <- rbindlist(list(
        mts_top[, ..cols],
        mts_com[, ..cols]
      ), use.names = TRUE)[, cell_type := ct]
    }
    
    # add to list
    mts_top[, cell_type := ct]
    mts_top[, n_pks := n_pks][, n_enh_pks := n_enh_pks]
    cmb_ls[[it]][[ct]] <- mts_top
    
  }

}

# combine results across cell types and iterations
cmb_dt <- rbindlist(lapply(cmb_ls, rbindlist, idcol = "cell_type"), idcol = "iteration")

# count fractions of peaks explained by motifs combinations
cmb_dt[, motif_frac_occur := motif_occur / n_pks]
cmb_dt[, motif_frac_enh_occur := motif_enh_occur / n_enh_pks]

# save
fwrite(
  cmb_dt, 
  file.path(syn_dir, syn_fn), 
  sep = "\t"
)
```

### Plot

Load data

```{r}
# results to compare
syn_sub_dirs <- c(
  "0.80 enrich" = "q0.8-hits-enrich-assign-motifs-ovl-0.5",
  # "0.85 enrich" = "q0.85-hits-enrich-assign-motifs-ovl-0.5",
  "0.90 enrich" = "q0.9-hits-enrich-assign-motifs-ovl-0.5",
  "0.95 enrich" = "q0.95-hits-enrich-assign-motifs-ovl-0.5",
  "0.80 active" = "q0.8-hits-active-motifs-ovl-0.5",
  "0.90 active" = "q0.9-hits-active-motifs-ovl-0.5",
  "0.95 active" = "q0.95-hits-active-motifs-ovl-0.5"
)

# motif hits file
# this contains all motifs hits
mts_ct <- rbindlist(sapply(syn_sub_dirs, function(x) {
  message(x)
  fn <- file.path(syn_dir, x, "motif-hits-selected.tsv.gz")
  message(fn)
  fread(fn)[, iteration := x]
}, simplify = FALSE, USE.NAMES = TRUE), fill = TRUE)

# syntax results file
# this data only contains motifs that are in > 10% peaks
pks_fcs_thr <- 1.5
pks_fdr_thr <- 0.01
if (!is.null(pks_fcs_thr) & !is.null(pks_fdr_thr)) {
  syn_fn <- sprintf(
    "motif-hits-combinations-in-peaks-FC-%s-FDR-%s.tsv.gz", 
    pks_fcs_thr, pks_fdr_thr
  )
} else if (is.null(pks_fcs_thr) & !is.null(pks_fcs_thr)) {
  syn_fn <- sprintf(
    "motif-hits-combinations-in-peaks-FDR-%s.tsv.gz", 
    pks_fdr_thr
  )
} else if (!is.null(pks_fcs_thr) & is.null(pks_fdr_thr)) {
  syn_fn <- sprintf(
    "motif-hits-combinations-in-peaks-FC-%s.tsv.gz", 
    pks_fcs_thr
  )
} else {
  syn_fn <- "motif-hits-combinations-in-peaks.tsv.gz"
}
cmb_dt <- fread(file.path(syn_dir, syn_fn))

# filter motif hits to only include those in the syntax results
mts_ct <- merge.data.table(
  mts_ct, unique(cmb_dt[, .(cell_type, peak)]), 
  by = c("cell_type", "peak"),
  sort = FALSE
)

# order for plotting
cmb_dt[, cell_type := factor(cell_type, levels = cell_types)]
cmb_dt[, iteration := factor(iteration, levels = syn_sub_dirs)]
```

  - number of peaks and motifs per cell type

```{r}
# order for plotting
mts_ct[, cell_type := factor(cell_type, levels = cell_types)]
mts_ct[, iteration := factor(iteration, levels = syn_sub_dirs)]

# peaks counts
mts_ct_pks <- unique(mts_ct[, .(cell_type, peak, iteration)])

# motif counts
mts_ct_mts <- unique(mts_ct[, .(cell_type, motif, iteration)])


# plot adult and gastrula separately
ct_list <- gp_list <- 
  structure(vector("list", length = 2), names = c("adult", "gastrula"))
for (stage in c("adult", "gastrula")) {
  
  # cell types to consider
  cell_type_subset <- switch (
    stage,
    "adult" = adult_cell_types,
    "gastrula" = gastr_cell_types
  )
  
  # list of data to plot
  ct_list[[stage]] <- list(
    "# peaks" = mts_ct_pks,
    "# motifs" = mts_ct_mts
  )
  
  # peaks counts
  gp_list[[stage]] <- lapply(seq_along(ct_list[[stage]]), function(i) {
    dt <- ct_list[[stage]][[i]]
    dt <- dt[cell_type %in% cell_type_subset]
    nm <- names(ct_list[[stage]])[i]
    max_bar_height <- max(dt[, .N, cell_type]$N)
    
    # plot
    ggplot(dt, aes(iteration, fill = cell_type, color = cell_type)) + 
      geom_bar() +
      geom_text(
        aes(
          label = after_stat(count),
          y = after_stat(ifelse(count < 0.15 * max_bar_height, count + 0.05 * max_bar_height, count / 2))
        ),
        stat = "count", 
        size = 3, angle = 90
      ) +
      scale_fill_manual(values = ct_cols) +
      scale_color_manual(values = structure(
        colorspace::darken(ct_cols, 0.6),
        names = names(ct_cols)
      )) +
      scale_x_discrete(
        breaks = syn_sub_dirs,
        labels = names(syn_sub_dirs)
      ) +
      scale_y_continuous(
        expand = expansion(mult = c(0, 0.15))
      ) +
      facet_grid(. ~ cell_type, switch = "x") +
      labs(y = nm) +
      theme(
        #axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
        #strip.text.x.bottom = element_text(angle = 90, vjust = 0.5, hjust = 1),
        strip.text.x.bottom = element_blank(),
        panel.grid.major.y = element_line(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        legend.position = "none"
      )
  })
  
}
```

  - fraction of peaks each motif is in
  
```{r}
# fraction of peaks with motifs
for (stage in c("adult", "gastrula")) {
    
  # cell types to consider
  cell_type_subset <- switch (
    stage,
    "adult" = adult_cell_types,
    "gastrula" = gastr_cell_types
  )
  
  # peaks with motifs fraction
  dt <- unique(mts_ct[, .(cell_type, peak, motif, iteration)])
  dt <- dt[cell_type %in% cell_type_subset]
  dt[, n_peaks := length(unique(.SD$peak)), .(cell_type, iteration)]
  dt[, motif_in_pekas := length(unique(.SD$peak)), .(cell_type, motif, iteration)]
  dt[, motif_in_pekas := motif_in_pekas / n_peaks]
  nm <- "Fraction of motifs"
  
  # plot
  gp <- ggplot(dt, aes(iteration, motif_in_pekas, fill = cell_type, color = cell_type)) + 
    geom_boxplot() +
    scale_fill_manual(values = ct_cols) +
    scale_color_manual(values = structure(
      colorspace::darken(ct_cols, 0.6),
      names = names(ct_cols)
    )) +
    scale_y_continuous(
      expand = expansion(mult = c(0, 0.15))
    ) +
    facet_grid(. ~ cell_type, switch = "x") +
    labs(y = nm) +
    theme(
      #axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.title.x = element_blank(),
      #strip.text.x.bottom = element_text(angle = 90, vjust = 0.5, hjust = 1),
      strip.text.x.bottom = element_blank(),
      panel.grid.major.y = element_line(),
      panel.border = element_blank(),
      panel.background = element_blank(),
      legend.position = "none"
    )
  # gp_list[[stage]][[nm]] <- gp
}
```

  - fraction of peaks with combinations of motifs

```{r}
# plot fractions of peaks explained by motifs combinations
for (stage in c("adult", "gastrula")) {
  
  # cell types to consider
  cell_type_subset <- switch (
    stage,
    "adult" = adult_cell_types,
    "gastrula" = gastr_cell_types
  )
  
  # peaks with combinations of motifs
  dt <- unique(cmb_dt[, .(cell_type, N, motif, motif_frac_occur, motif_occur, iteration)])
  dt <- dt[cell_type %in% cell_type_subset]
  dt[, motif_occur := as.numeric(motif_occur)]
  dt <- melt.data.table(dt, measure.vars = c("motif_occur", "motif_frac_occur"))
  dt[variable == "motif_frac_occur", value := value * 100]
  dt[, variable := ifelse(variable == "motif_occur", "#", "%")]
  dt[, variable := factor(variable, levels = c("#", "%"))]
  dt[, cell_type := factor(cell_type, levels = cell_types)]
  nm <- "Peaks with motif(s)"
  
  # plot
  gp <- ggplot(dt, aes(iteration, value, fill = cell_type, color = cell_type)) + 
    geom_boxplot() +
    scale_fill_manual(values = ct_cols) +
    scale_color_manual(values = structure(
      colorspace::darken(ct_cols, 0.6),
      names = names(ct_cols)
    )) +
    scale_x_discrete(
      breaks = syn_sub_dirs,
      labels = names(syn_sub_dirs)
    ) +
    facet_grid(
      N + variable ~ cell_type, 
      switch = "x", 
      scales = "free_y",
      labeller = labeller(N = c(
        "1" = "1 motif", "2" = "2 motifs", "3" = "3 motifs", "4" = "4 motifs"
      ))
    ) +
    labs(y = nm) +
    theme(
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
      axis.title.x = element_blank(),
      strip.text.x.bottom = element_text(angle = 90, vjust = 0.5, hjust = 1),
      panel.grid.major.y = element_line(),
      panel.border = element_blank(),
      panel.background = element_blank(),
      legend.position = "none"
    )
  gp_list[[stage]][[nm]] <- gp
}
```

Save plots

```{r}
# assemble plots
for (stage in c("adult", "gastrula")) {
  ggp_ct <- patchwork::wrap_plots(
    gp_list[[stage]], 
    ncol = 1,
    heights = c(1, 1, 8)
  )
  
  # save plot
  pdf(
    file.path(fig_dir, str_replace(syn_fn, ".tsv.gz", sprintf("-counts-%s.pdf", stage))),
    width = 30, height = 26
  )
  print(ggp_ct)
  dev.off()
}
```

Plot logos for top motifs combinations for each iteration.

```{r}
# subset motifs combinations only
cob_dt <- unique(cmb_dt[N > 1, .(iteration, cell_type, N, motif, motif_occur, motif_frac_occur)])

# rank each motif combo by fraction of cell type peaks it appears in
setorder(cob_dt, iteration, cell_type, -motif_frac_occur)
cob_dt[, rank := 1:nrow(.SD), .(iteration, cell_type)]

# load motifs logos
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
mots_arc_lst <- unlist(lapply(c(
  file.path("Results", "Archetypes", sprintf("motif-archetypes-%s-pwms.rds", arc_id)),
  file.path("Results", "Motifs", "motifs.rds")
), readRDS))
names(mots_arc_lst) <- sapply(mots_arc_lst, function(m) m@name)

# load motif-to-TF assignments
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
arc_as <- fread(file.path(arc_dir, sprintf(
  "motif-assignment-archetypes-%s.tsv", arc_id
)))

# make gene labels (need this for mapping back to motifs)
arc_as <- makeGeneLabels(arc_as)

# loop over iterations
for (it in syn_sub_dirs) {
  message("# # # # # # # # # # # # # # # # # # # # # # # # # # # # #")
  message("#     ", it)
  message("# # # # # # # # # # # # # # # # # # # # # # # # # # # # #")
  
  # loop over cell types
  cl <- lapply(cell_types, function(ct) {
    
    message(ct)
    dc <- cob_dt[iteration == it][cell_type == ct]
    
    # get top ranked motif combos
    is <- pmin(max(dc$rank), 20)
    lr <- lapply(seq_len(is), function(i) {
      
      dt <- dc[rank == i]
      ms <- str_split(dt$motif, " \\+ ")[[1]]
      
      # title: in how many peaks (percent) motif combo appears
      tl <- sprintf("%d: %d peaks (%.1f%%)", i, dt$motif_occur, dt$motif_frac_occur * 100)
      
      message(sprintf("%s with %s", tl, dt$motif))
      
      # individual motifs logos
      lg <- lapply(ms, function(mt) {
        
        # if multiple genes for motif, check most frequent motif
        mm <- str_split(mt, " \\| ")[[1]]
        ml <- unlist(lapply(mm, function(x) {
          if (x %in% arc_as$gene_label) {
            arc_as[gene_label == x]$archetype_name
          } else {
            x
          }
        }))
        if (length(ml) > 1) {
          mm <- names(sort(table(ml),decreasing=TRUE)[1])
        }
        if (mm %in% arc_as$gene_label) {
          mm <- arc_as[gene_label == mm]$archetype_name
        }
        
        # map gene
        mg <- NULL
        if (mm %in% arc_as$archetype_name) {
          gs <- arc_as[archetype_name == mm]$gene_label
          mg <- paste(
            substr(gs, 1, 30)[1:pmin(length(gs),3)], 
            collapse = " |\n"
          )
        }

        # motif logo
        ts <- ifelse(!is.null(mg), sprintf("%s (%s)", mg, mm), mm)
        if (match(mt, ms) == 1) {
          ts <- sprintf("%s\n%s", tl, ts)
        } else {
          ts <- sprintf("\n%s", ts)
        }
        ggseqlogo(mots_arc_lst[[mm]]@motif) + 
          theme_void() +
          labs(subtitle = ts)

      })
      
      # plot logos for motif combination
      patchwork::wrap_plots(lg, nrow = 1) + plot_annotation(title = tl)
      
    })
    

    patchwork::wrap_plots(lr, ncol = 1) + plot_annotation(title = ct)
    
  })
  
  # save plot
  pdf(
    
    file.path(fig_dir, str_replace(syn_fn, ".tsv.gz", sprintf("-logos-%s.pdf", it))),
    width = 6, height = 28
  )
  print(cl)
  dev.off()
  
}

```

Plot barplots of fraction of peaks for each motif combination.

```{r}
# helper function for plotting integer breaks
int_breaks <- function(x, n = 5) {
  l <- pretty(x, n)
  l[abs(l %% 1) < .Machine$double.eps ^ 0.5] 
}

# list to save the plots
gp_list <- structure(vector("list", length = length(cell_types)), names = cell_types)

# plot fractions of peaks explained by motifs combinations
for (ct in cell_types) {
  
  ct_list <- structure(vector("list", length = length(syn_sub_dirs)), names = syn_sub_dirs)
  
  for (it in syn_sub_dirs) {
  
    # select data
    cmb_ct <- cmb_dt[cell_type == ct & iteration == it]
    cmb_ct <- unique(cmb_ct[, .(motif, motif_occur, motif_enh_occur, N, n_pks, n_enh_pks)])
    setorder(cmb_ct, N, -motif_occur)
    cmb_ct[, motif := factor(motif, levels = rev(unique(cmb_ct$motif)))]
    cmb_ct[, motif_perc := motif_occur / n_pks * 100]
    cmb_ct[, motif_enh_perc := motif_enh_occur / n_enh_pks * 100]
    cmb_ct <- melt.data.table(
      cmb_ct, 
      measure.vars = c("motif_perc", "motif_enh_perc"), 
      variable.name = "peaks_set", 
      value.name = "value"
    )
    
    if (nrow(cmb_ct) > 0) { 
      
      # only show in plot motifs with hits in more than 1 peak 
      cmb_ct <- cmb_ct[motif_occur > 1]
      
      # only show in plot motifs with hits in more than 2 peaks
      cmb_mt <- cmb_ct[motif_occur > 2]
      if (length(unique(cmb_mt$motif)) > 10)
        cmb_ct <- cmb_mt
      
      # select top motifs to show in plot
      i <- 1
      while (length(unique(cmb_ct$motif)) > 80) {
        cmb_mt <- cmb_ct[motif_occur > 10*i]
        if (length(unique(cmb_mt$motif)) < 40)
          break
        cmb_ct <- cmb_mt
        print(sprintf(
          "occurance > %s: %s motifs", 10*i, length(unique(cmb_mt$motif))
        ))
        i <- i + 1
      }
  
      # plot
      cpl_ct <- ggplot(cmb_ct, aes(value, motif)) + 
        geom_bar(
          stat = "identity", 
          fill = ct_cols[ct], 
          color = colorspace::darken(ct_cols[ct], 0.5)
        ) +
        scale_x_continuous(
          expand = expansion(mult = c(0, 0.15)),
          name = "% of peaks"
        ) +
        geom_text(
          aes(label = sprintf(" %d (%.1f%%) ", motif_occur, value)),
          hjust = 0, vjust = 0.5, size = 6, 
          color = colorspace::darken(ct_cols[ct], 0.5)
        ) +
        scale_y_discrete(
          breaks = unique(cmb_ct$motif),
          labels = str_replace_all(unique(cmb_ct$motif), "\\+", "+\n"),
        ) +
        labs(title = ct, subtitle = it) +
        theme(
          panel.grid.major.x = element_line(colour = "grey", size = 0.25),
          panel.grid.minor.x = element_line(colour = "grey", size = 0.05),
        )
      if (length(unique(cmb_ct$N)) > 1) {
        cpl_ct <- tryCatch({
          cpl_ct + facet_grid(
            N ~ peaks_set, 
            scales = "free", space = "free", 
            labeller = labeller(
              "peaks_set" = c("motif_perc" = "% of peaks", "motif_enh_perc" = "% of enhancers"),
              "N" = function(x) ifelse(x == 1, "1 motif", paste0(x, " motifs"))
            )
          )
        }, error = function(e) cpl_ct)
      } else {
        cpl_ct <- tryCatch({
          cpl_ct <- cpl_ct + 
            ggforce::facet_col(
              vars(peaks_set), 
              scales = "free_x", space = "free", 
              strip.position = "right",
              labeller = labeller("peaks_set" = c("motif_perc" = "% of peaks", "motif_enh_perc" = "% of enhancers"))
            )
        }, error = function(e) cpl_ct)
      }
    } else {
      cpl_ct <- NULL
    }
    
    ct_list[[it]] <- cpl_ct
    
  }
  
  gp_list[[ct]] <- ct_list
}


# save plots
pdf(
  file.path(fig_dir, str_replace(syn_fn, ".tsv.gz", "-barplots.pdf")), 
  width = 24, height = 42
)
for (i in seq_along(gp_list)) {
  tryCatch(
    print(gp_list[[i]]), 
    error = function(e) NULL
  ) 
}
dev.off()
```

## Summaries

Load results

```{r}
syn_sub_dir <- "q0.8-hits-enrich-assign-motifs-ovl-0.5"
mts_ct <- fread(file.path(syn_dir, syn_sub_dir, "motif-hits-selected.tsv.gz"))
amt_ct <- fread(file.path(syn_dir, syn_sub_dir, "motif-hits-all.tsv.gz"))
```

Compare number of motif hits per peak before and after reducing motif hits.

```{r}
all_hits <- rbindlist(list(
  "all" = amt_ct, 
  "reduced" = mts_ct
), idcol = "set")

# how many (different or same) motifs hits per peak?
mta_pks_mts_diff <- unique(all_hits[,.(motif, peak, set)])[, .N, .(peak, set)]
mta_pks_mts_same <- unique(all_hits[, .N, .(motif, peak, set)])

ggp_pks_mts_same <- ggplot(mta_pks_mts_same, aes(N)) + 
  geom_histogram(bins = 20, color = "white") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)), trans = "log10") +
  facet_wrap(set ~ ., scales = "free") +
  labs(x = "Number of same motif hits per peak", y = "Number of peaks") +
  theme(panel.grid.major = element_line())
  
ggp_pks_mts_diff <- ggplot(mta_pks_mts_diff, aes(N)) + 
  geom_histogram(bins = 20, color = "white") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)), trans = "log10") +
  facet_wrap(set ~ ., scales = "free") +
  labs(x = "Number of different motifs hits per peak", y = "Number of peaks") +
  theme(panel.grid.major = element_line())

ggp_pks_mts <- ggp_pks_mts_same / ggp_pks_mts_diff + plot_layout(ncol = 1)
ggsave(
  file.path(fig_dir, "motif-hits-per-peak.pdf"), 
  ggp_pks_mts, width = 8, height = 6
)
```

Number of motif hits per peak per cell type.

```{r}
# count motifs per peaks in cell types
mta_pks_mts_cts <- unique(mts_ct[,.(motif, peak, cell_type)])[, .N, .(peak, cell_type)]

# order cell types
mta_pks_mts_cts[, cell_type := factor(cell_type, levels = cell_types)]

# plot
ggp_pks_mts <- ggplot(mta_pks_mts_cts, aes(cell_type, N, color = cell_type, fill = cell_type)) + 
  geom_boxplot(outlier.shape = 21) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 5)) +
  scale_fill_manual(values = ct_cols) +
  scale_color_manual(values = structure(
    colorspace::darken(ct_cols, 0.5),
    names = names(ct_cols)
  )) +
  annotate(
    "text",
    label = sprintf("median = %i", median(mta_pks_mts_cts$N)),
    y = median(mta_pks_mts_cts$N) + 10,
    x = cell_types[3],
    size = 6
  ) +
  labs(
    y = "# motifs per peak", x = ""
  ) +
  theme(
    panel.grid.major.y = element_line(colour = "grey", size = 0.25),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    legend.position = "none"
  )

```

Number of motifs per cell types.

```{r}
# unique motif hits per cell type
mts_ct_uniq <- unique(mts_ct[, .(cell_type, motif)])

# prder cell types
mts_ct_uniq[, cell_type := factor(cell_type, levels = cell_types)]

# counts
mts_ct_uniq_n <- mts_ct_uniq[, .(n_motifs = .N), .(cell_type)]

# plot
gp_mts <- ggplot(
  mts_ct_uniq_n,
  aes(
    cell_type, n_motifs, 
    fill = cell_type,
    color = cell_type
  )
) + 
  geom_bar(stat = "identity") +
  geom_text(
    aes(label = n_motifs), 
    vjust = -0.5, hjust = 0.5, size = 4, color = "black"
  ) +
  annotate(
    "text",
    label = sprintf("median = %i", round(median(mts_ct_uniq_n$n_motifs))),
    y = median(mts_ct_uniq_n$n_motifs) + 30,
    x = cell_types[3],
    size = 6
  ) +
  scale_fill_manual(
    values = ct_cols, 
    guide = "none"
  ) +
  scale_color_manual(values = structure(
    colorspace::darken(ct_cols, 0.5),
    names = names(ct_cols)
  ), guide = "none") +  
  scale_y_continuous(
    expand = expansion(mult = c(0, 0.15))
  ) +
  labs(x = "", y = "motifs") +
  theme(
    legend.position = "none",
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    panel.grid.major.y = element_line(colour = "grey", size = 0.25)
  )

```

Save plots

```{r}
gp_pms <- gp_mts / ggp_pks_mts
ggsave(
  file.path(fig_dir, "motif-hits-per-peak-cell-type.pdf"), 
  gp_pms, width = 9, height = 8.5
)
```

Annotate motifs and peaks with metadata.

```{r}
# # # # # # # # # # # # #
#  motifs hits results  #
# # # # # # # # # # # # #

# reduced motif hits
mts_ct[, archetype_name := motif]

# # # # # # # # # # # # # #
#  peaks classification   #
# # # # # # # # # # # # # #

# load peaks classification
pks_dt <- fread(file.path(pks_dir, "Peaks_cell_type_promoter_annotation.tsv.gz"))

# annotations for each peak: CP > SP > AP > NO
pks_dt <- unique(pks_dt[, .(peak, promoter, cell_type)])
pks_dt[promoter == "AP+", promoter := "AP"]
pks_dt[, promoter := factor(promoter, levels = c("CP", "SP", "AP", "NO"))]
setorder(pks_dt, peak, promoter)
setnames(pks_dt, "cell_type", "broad_cell_type")
pks_dt <- pks_dt[, .SD[1], .(peak, broad_cell_type)]
pks_dt <- unique(pks_dt)
stopifnot(!any(pks_dt[,.N,.(peak, broad_cell_type)]$N > 1))

# merge hits results with peaks classification
mts_ct <- merge.data.table(
  mts_ct, bct_maps,
  by = "cell_type", all.x = TRUE
)
mts_ct <- merge.data.table(
  mts_ct, pks_dt,
  by = c("peak", "broad_cell_type"), 
  all.x = TRUE
)
mts_ct[is.na(promoter), promoter := "NO"]

# # # # # # # # # # # #
#  archetype family   #
# # # # # # # # # # # #

# load archetype family info
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
cor_dt <- fread(file.path(
  "results", "Archetypes",
  sprintf("ChromVAR-%s", arc_id), 
  "correlation-seacells-archetype-motif-score-gene.tsv.gz"
))

# add archetype family info
mts_ct <- merge.data.table(
  mts_ct, 
  unique(cor_dt[, .(archetype_name, archetype_family)]),
  by = "archetype_name",
  sort = FALSE, all.x = TRUE
)
mts_ct[archetype_name == "FoxQ2d", archetype_family := "Forkhead"]

# # # # # # # # # # # # # # #
#  motif to TF assignment   #
# # # # # # # # # # # # # # #

# load motif-to-TF assignments
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
arc_as <- fread(file.path(mta_dir, sprintf(
  "motif-assignment-archetypes-%s.tsv.gz", arc_id
)))

# merge hits results with motif assignments
mts_ct <- merge.data.table(
  mts_ct, unique(arc_as[, .(
    gene, gene_name, common_name, og, pfam, tf_family, 
    archetype_name, CisBP_assignment
  )]),
  by = c("archetype_name"),
  all.x = TRUE, sort = FALSE, allow.cartesian = TRUE
)
mts_ct[is.na(mts_ct)] <- ""

# how many archetypes assigned to TFs are among the selected motifs?
arc_sl <- unique(arc_as[, .(archetype_name)])
arc_sl[, selected := archetype_name %in% mts_ct$archetype_name]
arc_sl[, .N, selected]

# how many of the selected motifs are assigned to TFs?
arc_tf <- unique(mts_ct[, .(archetype_name)])
arc_tf[, assigned := archetype_name %in% arc_as$archetype_name]
arc_tf[, .N, assigned]

# make gene labels
mts_ct[gene_name == "" & common_name != "", gene_name := common_name]
mts_ct[, gene_label := common_name]
mts_ct[gene_label == "", gene_label := ifelse(nchar(gene_name) > 45, paste0(substr(gene_name, 1, 43), "..."), gene_name)]
mts_ct[gene_label == "", gene_label := ifelse(nchar(og) > 45, paste0(substr(og, 1, 43), "..."), og)]
mts_ct[gene_label == "", gene_label := ifelse(nchar(pfam) > 45, paste0(substr(pfam, 1, 43), "..."), pfam)]
stopifnot(nrow(mts_ct[gene != "" & gene_label == ""]) == 0)

# count motif hits per cell type
mts_ct[, cell_type := factor(cell_type, levels = cell_types)]
mts_ct[, n_peaks := length(unique(.SD$peak)), .(cell_type)]
mts_ct[, n_peaks_motif := length(unique(.SD$peak)), .(cell_type, archetype_name)]
mts_ct[, frac_peaks_motif := n_peaks_motif / n_peaks]
```

Plot motif occurrences together on dotmap with motif enrichment FC.

```{r}
# we will order data for plotting by motif enrichment FC

# load enrichment data (significant, non-redundant)
# mta_en <- fread(file.path(mta_dir, "motif-enrichment-mona-q0.98-FC-1-padj-0.001.tsv"))
# mta_en[, cell_type := factor(cell_type, levels = cell_types)]
# mta_en[, archetype_name := factor(archetype_name, levels = unique(mta_en$archetype_name))]

# load enrichment data (all)
mta_en <- rbindlist(lapply(c(
  file.path(mta_dir, "motif-enrichment-cell-type-mona-q0.98.tsv"),
  file.path(arc_dir, "motif-enrichment-cell-type-archetypes-PPM-PCC-0.8-IC0.5-5bp-mona-q0.95.tsv")
), fread))
mta_en <- unique(mta_en[,.(cell_type, motif, fc, pval, padj)])

# cluster enrichment data for plot
mta_en[, cell_type := factor(cell_type, levels = cell_types)]
mta_en[, minuslog10padj := -1 * log10(padj)]
padj_dt <- unique(mta_en[, .(motif, cell_type, minuslog10padj)])
padj_dt <- dcast.data.table(padj_dt, motif ~ cell_type, value.var = "minuslog10padj")
padj_mt <- as.matrix(padj_dt[, -1])
rownames(padj_mt) <- padj_dt[[1]]
arc_ord <- order(apply(padj_mt, 1, which.max))
arc_lvl <- rownames(padj_mt)[arc_ord]
mta_en[, motif := factor(motif, levels = arc_lvl)]
setorder(mta_en, motif)
setnames(mta_en, "motif", "archetype_name")

# select significant archetypes
# fc_thr <- 1
# pa_thr <- 0.001
# arc_sig <- unique(mta_en[fc>fc_thr & padj<pa_thr]$motif)
# length(arc_sig)
# mta_en <- mta_en[archetype_name %in% arc_sig]

# count motif hits data for plotting
mts_ns <- unique(mts_ct[, .(
  cell_type, archetype_name, archetype_family,
  gene, gene_label,
  n_peaks, n_peaks_motif, frac_peaks_motif,
  fc, pval, padj
)])
stopifnot(!any(mts_ns[,.N,.(cell_type, archetype_name, gene)]$N > 1))
mts_ns[, gene_archetype := paste(gene, archetype_name, sep = " | ")]

# transform for plotting
mts_ns[, cell_type := factor(cell_type, levels = cell_types)]
mts_ns[, archetype_name := factor(archetype_name, levels = unique(mta_en$archetype_name))]
setorder(mts_ns, archetype_name, cell_type)
mts_ns[, gene_archetype := factor(gene_archetype, levels = unique(mts_ns$gene_archetype))]
mts_ns[, fc_scaled := pmin(fc, 6)]
mts_ns[, minuslog10padj := -1 * log10(padj)]
mts_ns[, minuslog10padj_scaled := pmin(minuslog10padj, 30)]

# archetype family colors
arc_fam_vec <- sort(unique(mts_ns$archetype_family))
arc_fam_col <- structure(
  colorRampPalette(RColorBrewer::brewer.pal(8, "Dark2"))(length(arc_fam_vec)),
  names = arc_fam_vec
)
arc_fam_col[names(arc_fam_col)==""] <- "white"

# plot motif enrichment dotmap
mts_gp_occ <- ggplot(
  mts_ns, 
  aes(cell_type, gene_archetype)
  ) +
  geom_point(
    aes(size = frac_peaks_motif, fill = fc_scaled),
    shape = 21
  ) +
  geom_text(
    data = unique(mts_ns[,.(gene_archetype, archetype_name)]),
    aes(y = gene_archetype, label = archetype_name),
    x = length(unique(mts_ns$cell_type)) + 1,
    hjust = 0,
    size = 2,
    inherit.aes = FALSE
  ) +
  scale_y_discrete(
    breaks = mts_ns[gene_label != ""]$gene_archetype,
    labels = mts_ns[gene_label != ""]$gene_label
  ) +
  scale_x_discrete(
    expand = expansion(mult = c(0.02, 0.5))
  ) +
  scale_fill_gradientn(
    name = "motif enrichment\nfold change",
    breaks = c(0, 2, 4, 6, 8),
    colours = c(
      "white", "#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15", "#7a0105"
    )
  ) +
  scale_size_continuous(
    name = "fraction of\ncell type-specific peaks\nwith motif hits",
    limits = c(0, 0.8),
    range = c(0, 6)
  ) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 8),
    axis.text.y = element_text(size = 6),
    panel.grid.major = element_line(linewidth = 0.25),
    axis.title = element_blank(),
    plot.margin = margin(5.5, 40, 5.5, 40)
  )

# archetype family annotation colorbar
mts_dt_arc <- unique(mts_ns[,.(gene_archetype, archetype_family)])
mts_dt_arc[, x := 1]
mts_gp_arc <- ggplot(mts_dt_arc) +
  geom_tile(
    aes(x = x, y = gene_archetype, fill = archetype_family),
  ) +
  scale_y_discrete(
    position = "right",
    breaks = mts_dt_arc$gene_archetype,
    labels = mts_dt_arc$archetype_family,
  ) +
  scale_fill_manual(values = arc_fam_col) +
  theme_void() +
  theme(
    axis.text.y = element_text(size = 6, hjust = 0),
    leegend.position = "none"
  )

mts_gp <- mts_gp_occ +
  plot_spacer() +
  (mts_gp_arc & theme(legend.position = "none")) + 
  plot_layout(nrow = 1, widths = c(20, -2.7, 0.25), guides = "collect")

ggsave(
  file.path(fig_dir, "motif-hits-number-fc-dotmap.pdf"), 
  mts_gp, height = 42, width = 12, limitsize = FALSE
)
```

Count motif combinations (not considering order, distance...) per cell type.

```{r}
# subset motifs assigned to TFs
use_genes_assigned_to_motfs <- FALSE

# subset motifs assigned to active TFs
use_active_tfs <- FALSE
if (use_active_tfs == TRUE) {
  grn_tfs <- fread(file.path(
    grn_dir, 
    "networks", 
    "grn_tfs_info_expression_fc_0.4_accessibility_access_0.4_chromvar_4.tsv"
  ))
  grn_tfs <- unique(grn_tfs[,.(motif, gene, zscore, cell_type)])
}

# list to save results
cmb_ls <- structure(vector("list", length = length(cell_types)), names = cell_types)

# loop over cell types
require(pbapply)
for (ct in cell_types) {
  
  message(ct)
  cols <- c("N", "peak", "promoter", "motif", "motif_occur", "motif_nocp_occur")
  
  # make a matrix of motif hits in peaks
  if (use_genes_assigned_to_motfs == TRUE) {
    mts_dat <- unique(
      mts_ct[cell_type == ct & gene != "", .(
        cell_type, peak, promoter, motif,
        start, end,  # include if we want all instances of motif in a peak
        gene, gene_label, common_name
      )]
    )
    if (use_active_tfs == TRUE) {
      mts_dat <- merge.data.table(
        mts_dat, unique(grn_tfs[cell_type == ct]),
        by = c("motif", "gene", "cell_type"), 
        all = FALSE, sort = FALSE
      )
    }
  } else {
    mts_dat <- unique(
      mts_ct[cell_type == ct, .(
        cell_type, peak, promoter, motif,
        start, end  # include if we want all instances of motif in a peak
      )]
    )
  }
  
  # number of peaks in cell type
  n_pks <- length(unique(mts_dat$peak))
  n_nocp_pks <- length(unique(mts_dat[promoter != "CP"]$peak))
  
  # count in how many peaks a motif occurs
  occ_mts <- unique(
    mts_dat[, .(peak, promoter, motif)]
  )[, ':='(
    motif_occur = length(unique(.SD$peak)),
    motif_nocp_occur = length(unique(.SD[promoter != "CP"]$peak))
  ), motif]
  occ_mts <- unique(occ_mts[, .(motif, motif_occur, motif_nocp_occur)])
  
  # add to motifs hits table
  mts_dat <- merge.data.table(
    mts_dat, occ_mts, by = "motif", 
    all.x = TRUE, sort = FALSE
  )
  
  # genes instead of motifs
  if (use_genes_assigned_to_motfs == TRUE) {
    mts_dat[, genes := paste(unique(sort(.SD$gene)), collapse = " | "), .(motif)]
    mts_dat[, gene_label := paste(unique(c(
      sort(.SD[common_name != ""]$gene_label),
      sort(.SD[common_name == ""]$gene_label)
    )), collapse = " | "), .(motif)]
    mts_dat[nchar(gene_label) > 100, gene_label := paste0(
      substr(gene_label, 1, 97), "..."
    ), gene_label]
    mts_dat[, c("gene") := NULL]
    mts_dat <- unique(mts_dat)
    mts_dat[, motif := NULL]
    setnames(mts_dat, "gene_label", "motif")
  }

  # select motifs that have hits in more than 10% of peaks
  # mts_top <- mts_dat[motif_occur > 0.1 * length(unique(mts_dat$peak))]
  mts_top <- copy(mts_dat)
  mts_top[, N := 1]
  mts_top <- unique(mts_top[, ..cols])
  
  # find top combinations of motifs
  mts_com <- rbindlist(lapply(c(2), function(n) {
    tryCatch({
      message("Counting combinations of ", n, " motifs in ", ct, " peaks:")
      mts_comb <- combn(
        unique(mts_top$motif), n, simplify = FALSE
      )
      message("Number of combinations: ", length(mts_comb))
      rbindlist(pbapply::pblapply(mts_comb, function(x) {
        dt <- unique(mts_top[motif %in% x, .(peak, promoter, motif)])[, N := .N, peak]
        unique(dt[N == n][, motif := paste(x, collapse = " + ")])
      }))      
    }, error = function(e) NULL)
  }))
  
  # count in how many peaks a combination of motif occurs
  if (nrow(mts_com) > 0) { 
    mts_com[, ':='(
      motif_occur = length(unique(.SD$peak)),
      motif_nocp_occur = length(unique(.SD[promoter != "CP"]$peak))
    ), .(motif, N)]
    
    # combine with motifs hits table
    mts_top <- rbindlist(list(
      mts_top[, ..cols],
      mts_com[, ..cols]
    ), use.names = TRUE)[, cell_type := ct]
  }
  
  # add to list
  mts_top[, cell_type := ct]
  mts_top[, n_pks := n_pks][, n_nocp_pks := n_nocp_pks]
  cmb_ls[[ct]] <- mts_top
  
}

# combine results across cell types
cmb_dt <- rbindlist(cmb_ls)

# save 
fwrite(cmb_dt, file.path(syn_dir, "motif-combinations-per-cell-type.tsv.gz"))
```

Inspect top motif combinations per cell type

```{r}
# load the combinations calculated above
cmb_dt <- fread(file.path(syn_dir, "motif-combinations-per-cell-type.tsv.gz"))

# select cell type
cmb_ct <- cmb_dt[cell_type == "cnidocyte"]
cmb_sm <- cmb_ct[, .(num_peaks = .N), .(motif, N, n_pks)][order(-num_peaks)]

# pairs of motifs
cmb_2 <- cmb_sm[N == 2]

# split motif in two columns: motif1 and motif2
cmb_2[, c("motif1", "motif2") := tstrsplit(motif, " \\+ ")]
setnames(cmb_2, "motif", "motif_pair")

# split motif1 by | into rows
cmb_2 <- tidyr::separate_rows(cmb_2, motif1, sep = " \\| ")
cmb_2 <- tidyr::separate_rows(cmb_2, motif2, sep = " \\| ")
setDT(cmb_2)

# add TF info 

# select top active TFs for each possible pair
grn_ct <- grn_tfs[cell_type == "cnidocyte"]
# ...
cmb_2 <- cmb_2[, .SD[1], motif_pair]

# order
cmb_2[, motif_label := paste(motif1, motif2, sep = " + ")]
cmb_2[, motif_label := factor(motif_label, levels = rev(unique(cmb_2$motif_label)))]

# for plotting
cmb_2[, cell_type := "cnidocyte"]

# plot barplot
int_breaks <- function(x, n = 5) {
  l <- pretty(x, n)
  l[abs(l %% 1) < .Machine$double.eps ^ 0.5] 
}
ggplot(cmb_2[1:30], aes(num_peaks, motif_label, color = cell_type, fill = cell_type)) +
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_fill_manual(values = ct_cols) +
  scale_color_manual(values = structure(
    colorspace::darken(ct_cols, 0.5),
    names = names(ct_cols)
  )) +
  scale_x_continuous(
    expand = expansion(mult = c(0, 0.1)), 
    breaks = int_breaks,
    sec.axis = sec_axis(~ . / cmb_2$n_pks[1] * 100, name = "% of peaks")
  ) +
  theme(legend.position = "none") +
  facet_grid(~ cell_type, scales = "free_y") +
  labs(x = "# peaks", y = "motif pair")

ggsave(file.path(fig_dir, "motif-pairs-cnidocyte.pdf"), width = 10, height = 8)
```

Plot motif combinations...

```{r}
# helper function for plotting integer breaks
int_breaks <- function(x, n = 5) {
  l <- pretty(x, n)
  l[abs(l %% 1) < .Machine$double.eps ^ 0.5] 
}

# plot results
cpl_ls <- lapply(cell_types, function(ct) {
  
  message(ct)
  
  # select data
  cmb_ct <- cmb_dt[cell_type == ct]
  cmb_ct <- unique(cmb_ct[, .(motif, motif_occur, motif_nocp_occur, N, n_pks, n_nocp_pks)])
  setorder(cmb_ct, N, -motif_occur)
  cmb_ct[, motif := factor(motif, levels = rev(unique(cmb_ct$motif)))]
  
  if (nrow(cmb_ct) > 0) { 
    # number of peaks in cell type
    n_pks <- unique(cmb_ct$n_pks)
    n_nocp_pks <- unique(cmb_ct$n_nocp_pks)
    
    # only show in plot motifs with hits in more than 1 peak 
    cmb_ct <- cmb_ct[motif_occur > 1]
    
    # only show in plot motifs with hits in more than 2 peaks
    cmb_mt <- cmb_ct[motif_occur > 2]
    if (length(unique(cmb_mt$motif)) > 10)
      cmb_ct <- cmb_mt
    
    # select top motifs to show in plot
    i <- 1
    while (length(unique(cmb_ct$motif)) > 80) {
      cmb_mt <- cmb_ct[motif_occur > 10*i]
      if (length(unique(cmb_mt$motif)) < 40)
        break
      cmb_ct <- cmb_mt
      print(sprintf(
        "occurance > %s: %s motifs", 10*i, length(unique(cmb_mt$motif))
      ))
      i <- i + 1
    }
    
    # plot
    cpl_ct <- ggplot(cmb_ct, aes(motif_occur, motif)) + 
      geom_bar(stat = "identity", fill = ct_cols[ct]) +
      scale_x_continuous(
        expand = expansion(mult = c(0, 0.1)), 
        breaks = int_breaks,
        name = "number of peaks",
        sec.axis = sec_axis(~ . / n_nocp_pks * 100, name = "% of peaks")
      ) +
      scale_y_discrete(
        breaks = unique(cmb_ct$motif),
        labels = str_replace_all(unique(cmb_ct$motif), "\\+", "+\n"),
      ) +
      labs(title = ct) +
      theme(
        panel.grid.major.x = element_line(colour = "grey", size = 0.25),
        panel.grid.minor.x = element_line(colour = "grey", size = 0.05),
      )
    if (length(unique(cmb_ct$N)) > 1) {
      cpl_ct <- cpl_ct + 
        #facet_wrap("N", ncol = 1, scales = "free", strip.position = "right")
        ggforce::facet_col(vars(N), scales = "free", space = "free", strip.position = "right")
    }
  } else {
    cpl_ct <- NULL
  }
  
  cpl_ct
  
})

# save plots
pdf(
  file.path(fig_dir, "motif-TF-occurance-per-cell-type.pdf"), 
  width = 24, height = 42
)
tryCatch(print(cpl_ls), error = function(e) warning(e))
dev.off()

```


