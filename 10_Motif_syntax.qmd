---
title: "Motif syntax"
author: "Anamaria Elek"
date: today
format: 
  html:
    code-fold: false
    code-tools: false
    embed-resources: true
    highlight-style: github
    toc: true 
    code-line-numbers: false 
execute:
  eval: false
  message: false
  warning: false
---

```{r}
#| label: initialize
#| echo: FALSE
knitr::opts_chunk$set(echo = TRUE, fig.width=7, fig.height=5) 
```

In this notebook, we will explore motif syntax.

## Setup

Load packages and functions.

```{r}
#| label: setup

# load in-house functions
source("metacell_downstream_functions/Downstream_functions.R") 
source("metacell_downstream_functions/Gene_module_functions.R")
source("metacell_downstream_functions/utils.R")
source("motif-analysis/mta_downstream_functions.R")
source("scripts/scatac_helper_functions.R")

# global settings
options(stringsAsFactors = FALSE)

# load packages
library(RColorBrewer)
library(BSgenome.jaNemVect1.1.DToL.Assembly)
library(GenomicRanges)
library(data.table)
library(tidyr)
library(stringr)
library(ggplot2)
library(patchwork)
library(ggrepel)
library(ggside)
library(ggseqlogo)
library(universalmotif)
library(grid)
library(ArchR)
library(Seurat)
library(metacell)

# set ggplot2 theme
theme_blank <- theme_minimal() + theme(
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  panel.border = element_blank(),
  panel.grid=element_blank(),
  axis.ticks = element_blank(),
  text = element_text(size=20)
)
theme_py <- theme_light() + theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.border = element_rect(colour = "black", fill = NA),
  text = element_text(size=20),
  strip.placement = "outside", 
  strip.text = element_text(size=20, color="black"),
  strip.background = element_rect(fill="white")
)
theme_set(theme_py)

# helper function to make gene labels
makeGeneLabels <- function(dt) {
  dt[gene_name == "" & common_name != "", gene_name := common_name]
  dt[, gene_label := common_name]
  dt[gene_label == "", gene_label := ifelse(nchar(gene_name) > 45, paste0(substr(gene_name, 1, 43), "..."), gene_name)]
  dt[gene_label == "", gene_label := ifelse(nchar(og) > 45, paste0(substr(og, 1, 43), "..."), og)]
  dt[gene_label == "", gene_label := ifelse(nchar(pfam) > 45, paste0(substr(pfam, 1, 43), "..."), pfam)]
  stopifnot(nrow(dt[gene != "" & gene_label == ""]) == 0)
  return(dt)
}
```

Define directories to read the data from and save the results to.

```{r}
#| label: dirs

adult_dir <- "ArchRProj_Nvec_TSS4_frag200"
gastr_dir <- "ArchRProj_Nvec_gastrula"
pks_dir <- "results/Peaks"
mta_dir <- "results/Motifs"
arc_dir <- "results/Archetypes"
map_dir <- "results/Metacells"
grn_dir <- "results/GRN"
mod_dir <- "results/Modules"
syn_dir <- "results/Syntax"
dir.create(syn_dir, showWarnings = FALSE)
fig_dir <- "plots/Syntax"
dir.create(fig_dir, showWarnings = FALSE)
ann_dir <- "annotation"
```

Load gene annotations.

```{r}
# gene annotation
gnan <- fread(file.path(
  ann_dir, "Nematostella_DToL_FINAL.tsv"
))

# TF annotation
tfan <- fread(file.path(
  ann_dir, "Nematostella_DToL_TFs_FINAL.tsv"
))

# golden markers
gold <- fread(file.path(
  ann_dir, "golden-marks-231124.tsv"
), header = FALSE)
setnames(gold, c("common_name", "gene", "remark"))
```

Project-specific variables:

```{r}
ct_cols <- c(
  "cnidocyte"                  = "#ff42ff",
  "cnidocyte_gastrula"         = "#f7abf7",
  "ecto_pharynx"               = "#5bc0e8",
  "ectoderm"                   = "#51a0be",
  "ecto_aboral"                = "#045170",
  "EMS"                        = "#bdf5bd",
  "EMS_ecto_boundary"          = "#93dbce",
  "gastro_circular_muscle_1"   = "#85c90e",
  "gastro_circular_muscle_2"   = "#73b009",
  "gastro_parietal_muscle"     = "#8ceb10",
  "gastro_IRF1_2"              = "#c1eb05",
  "gastro_somatic_gonad"       = "#bde314",
  "muscle_tentacle_retractor"  = "#ffd700",
  "muscle_mesentery_retractor" = "#f0e229",
  "digestive_filaments_1"      = "#e33d3d",
  "digestive_filaments_2"      = "#d10606",
  "digestive_filaments_3"      = "#ad0303",
  "epidermis_1"                = "#04ccd4",
  "epidermis_2"                = "#16bacc",
  "precursors_PGC"             = "#bebebe",
  "precursors_endoNPC"         = "#8a8686",
  "precursors_NPC"             = "#636363",
  "NPC_1"                      = "#808d91",
  "NPC_2"                      = "#758d92",
  "neuron_GATA_Islet_1"        = "#0c82f7",
  "neuron_GATA_Islet_2"        = "#1175f0",
  "neuron_Pou4_FoxL2_1"        = "#101cde",
  "neuron_Pou4_FoxL2_2"        = "#0b16bf",
  "neuron_Pou4_FoxL2_3"        = "#2e39dd",
  "neuronal_gastrula"          = "#063cb9",
  "gland"                      = "#ff6f08",
  "gland_mucin"                = "#ff8f12"
)
cell_types <- names(ct_cols)
adult_cell_types <- c(
  "cnidocyte",
  "gastro_circular_muscle_1", 
  "gastro_circular_muscle_2",
  "gastro_parietal_muscle",
  "gastro_IRF1_2",
  "gastro_somatic_gonad",
  "muscle_mesentery_retractor",
  "muscle_tentacle_retractor",
  "digestive_filaments_1",
  "digestive_filaments_2",
  "digestive_filaments_3",
  "epidermis_1",
  "epidermis_2",
  "precursors_PGC",
  "precursors_endoNPC",
  "precursors_NPC",
  "neuron_GATA_Islet_1",
  "neuron_GATA_Islet_2",
  "neuron_Pou4_FoxL2_1",
  "neuron_Pou4_FoxL2_2",
  "neuron_Pou4_FoxL2_3",
  "gland"
)
gastr_cell_types <- c(setdiff(cell_types, adult_cell_types))
bct_cols <- toupper(c(
  "cnidocyte"                 = "#ff42ff",
  "ecto"                      = "#51a0be",
  "EMS"                       = "#bdf5bd",
  "gastro_circular_muscle"    = "#73b009",
  "gastro_parietal_muscle"    = "#8ceb10",
  "gastro"                    = "#85c90e",  
  "muscle"                    = "#ffd700",
  "digestive_filaments"       = "#e33d3d",
  "precursors"                = "#bebebe",
  "NPC"                       = "#808d91",
  "epidermis"                 = "#04ccd4",
  "neuron_GATA_Islet"         = "#1175f0",
  "neuron_Pou4_FoxL2"         = "#101cde",
  "neuronal"                  = "#063cb9",
  "gland"                     = "#ff6f08"
))
bct_maps <- setDT(cbind.data.frame(
  cell_type = cell_types,
  broad_cell_type = str_extract(cell_types, paste(names(bct_cols), collapse = "|"))
))
```

## Motif co-occurence in all peaks

First, we get locations of all motif hits (motif scores above the nth quantile of genomic binding energy).

```{r}
# load motif scores
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
q <- 0.95
mta_dt <- rbindlist(lapply(c(
  # archetypes
  file.path(arc_dir, sprintf("motif-scores-archetypes-%s-mona-q%s.tsv.gz", arc_id, q)),
  # experimental motifs
  file.path(mta_dir, sprintf("motif-scores-mona-q%s.tsv.gz", q))
), fread))

# calculate relative motif scores (independent of the motif length)
mta_dt[, relative_motif_score := motif_score / max(motif_score)]
mta_dt <- unique(mta_dt)
```

Get non-overlapping motif hits per peak for each individual motif.

```{r}
# testing dataset
#mta_hits_dt <- mta_dt[motif %in% c("ARCH1635_NEUROG2", "Pou4", "Shox2")]
#mta_hits_dt <- mta_hits_dt[peak %in% mta_hits_dt[order(peak)][, .N, peak][order(-N)][, .SD[1], N]$peak[1:10]]

#' Reduce motif hits to non-overlapping hits for each motif
#' 
#' @param dt dataframe with have individual motif hits in peaks in separate rows, it should have (at least) these columns: seqnames, start, end, motif, motif_score, peak
#' @return dataframe with non-overlapping motif hits
#' 
reduce_ovl_ocurrences <- function(dt) {

  # convert to data.table
  setDT(dt)

  # order data by motif and coordinate
  message(sprintf("%s Ordering %d instances of %d motifs", Sys.time(), nrow(dt), length(unique(dt$motif))))
  dt <- unique(dt[, .(seqnames, start, end, motif, motif_score, peak)])
  setorder(dt, motif, start)

  # identify groups of overlapping motif instances
  .mta_occurr_ovl <- function(dt) {
    message(sprintf("%s Identifying overlapping motif instances, this might take several minutes", Sys.time()))
    dt[, dist := start - lag(end), by = .(motif, peak)]
    dt[is.na(dist), dist := 1000]
    message(sprintf("%s Numbering motif occurrences per peak", Sys.time()))
    dt[, motif_occurrence := cumsum(dist > 0), by = .(motif, peak)]
    # count number of non-overlapping motif hits for individual motifs
    message(sprintf("%s Counting number of motif instances per peak", Sys.time()))
    dt[, motif_count := sum(dist > 0), .(motif, peak)]
  }
  .mta_occurr_ovl(dt)
  message(sprintf("%s Reduced mumber of motif instances to %d", Sys.time(), nrow(dt)))

  # for overlapping motif instances, take the ones with max score
  message(sprintf("%s Selecting motif instances with maximum score", Sys.time()))
  dt[, max_motif_score := max(motif_score), .(motif, peak, motif_occurrence)]
  dt <- dt[motif_score == max_motif_score]
  .mta_occurr_ovl(dt)
  message(sprintf("%s Reduced mumber of motif instances to %d", Sys.time(), nrow(dt)))

  # for motif instances that are still overlapping, 
  # take the coordiantes of maximum possible span
  message(sprintf("%s Selecting maximum span for overlapping instances with max score", Sys.time()))
  dt[, start := min(start), .(motif, peak, motif_occurrence)]
  dt[, end := max(end), .(motif, peak, motif_occurrence)]
  dt[, dist := NULL]
  dt[, max_motif_score := NULL]
  dt <- unique(dt)
  message(sprintf("%s Final number of non-overlapping motif instances: %d", Sys.time(), nrow(dt)))

  return(dt)
}

# mta_novl_hits_dt <- reduce_ovl_ocurrences(mta_hits_dt)
system.time({
  mta_novl_dt <- reduce_ovl_ocurrences(mta_dt)
})
saveRDS(
  mta_novl_dt, 
  file.path(syn_dir, sprintf("motif-hits-novl-%s-mona-q-%s.rds", arc_id, q))
)
```

A function to check co-occurence of pairs of motifs.

```{r}
messagetimed <- function(...) {
  message(sprintf("%s %s", Sys.time(), sprintf(...)))
}

count_co_occurrences <- function(dt, min_ovl = NULL) {
  
  # Convert to data.table
  setDT(dt)
  
  # If we don't want to check overlap between pairs of motifs
  # we can use matrix operations to count co-occurrences 
  # (this is much faster!)
  if (is.null(min_ovl)) {

    # Count the number of motif hits in each peak
    mta_hits_dc <- dcast.data.table(dt, peak ~ motif, fun.aggregate = length)
    mta_hits <- as.matrix(mta_hits_dc[, -1])
    rownames(mta_hits) <- mta_hits_dc[[1]]
    
    # Convert to a binary indicator matrix (1 if hit count > 0, otherwise 0)
    mta_hits_ind <- (mta_hits > 0) * 1
    
    # Count co-occurrences of all pairs of motifs using matrix multiplication
    count_matrix <- crossprod(mta_hits_ind)
    
    # Set diagonal to the number of motifs with at least 2 hits
    diag(count_matrix) <- colSums(mta_hits >= 2)
    
    # Return count matrix with motif names
    rownames(count_matrix) <- colnames(count_matrix) <- colnames(mta_hits_ind)
  
  # If we want to check for overlap between every pair of motifs
  # we have to loop through each peak and count pairs of motifs
  } else {

    # Function to check if motifs don't overlap
    motifs_nonoverlap <- function(end1, start2) {
      (end1 - start2) < min_ovl
    }

    # Initialize co-occurrence matrix
    motifs <- unique(dt$motif)
    co_occurrence_matrix <- matrix(
      0,
      nrow = length(motifs), ncol = length(motifs), 
      dimnames = list(motifs, motifs)
    )
    
    # Group data by peak
    grouped_df <- split(dt, by = "peak")

    # Save results to data table
    ds <- data.table()
    
    for (peak in names(grouped_df)) {
      
      message(sprintf(
        "%s Processing %s (%d/%d)", 
        Sys.time(), peak, which(names(grouped_df) == peak), length(names(grouped_df))
      ))
      
      group_df <- grouped_df[[peak]]
      unique_motifs <- unique(group_df$motif)
      ms <- CJ(m1 = unique_motifs, m2 = unique_motifs)[m1 <= m2] 
      
      for (pair in seq_len(nrow(ms))) {

        m1 <- ms$m1[pair]
        m2 <- ms$m2[pair]
        
        # different motifs:
        if (m1 != m2) {

          # filter instances and use vectorized overlap check
          motif1 <- group_df[motif == m1]
          motif2 <- group_df[motif == m2]

          if (nrow(motif1) > 0 & nrow(motif2) > 0) {
            # sort all motif pair instances so that motif1 is always the one with lower start
            m <- CJ(i = seq_len(nrow(motif1)), j = seq_len(nrow(motif2)))
            s <- data.table(
              m1 = motif1$motif_occurrence, m2 = motif2$motif_occurrence,
              m1_start = motif1$start[m$i],
              m2_start = motif2$start[m$j],
              m1_end = motif1$end[m$i],
              m2_end = motif2$end[m$j]
            )
            s[m1_start <= m2_start, ':='(start1 = m1_start, start2 = m2_start, end1 = m1_end, end2 = m2_end)]
            s[m2_start < m1_start, ':='(start1 = m2_start, start2 = m1_start, end1 = m2_end, end2 = m1_end)]
            s[, novl := motifs_nonoverlap(end1, start2)]
            s <- s[, .(novl = all(novl)), .(m1, m2)]
            novl <- any(s$novl)
          } else {
            novl <- FALSE
          }

        # same motifs
        } else {

          motif <- group_df[motif == m1]

          if (nrow(motif) > 1) {
            # sort all motif pair instances so that motif1 is always the one with lower start
            m <- CJ(i = seq_len(nrow(motif)), j = seq_len(nrow(motif)))
            m <- m[i != j]
            s <- data.table(
              m1 = motif$motif_occurrence, m2 = motif$motif_occurrence,
              m1_start = motif$start[m$i],
              m2_start = motif$start[m$j],
              m1_end = motif$end[m$i],
              m2_end = motif$end[m$j]
            )
            s[m1_start <= m2_start, ':='(start1 = m1_start, start2 = m2_start, end1 = m1_end, end2 = m2_end)]
            s[m2_start < m1_start, ':='(start1 = m2_start, start2 = m1_start, end1 = m2_end, end2 = m1_end)]
            s[, novl := motifs_nonoverlap(end1, start2)]
            s <- s[, .(novl = all(novl)), .(m1, m2)]
            novl <- any(s$novl)
          } else {
            novl <- FALSE
          }

        }

        # update matrix
        ms[pair, nonoverlapping := novl]
        if (novl == TRUE) {
          co_occurrence_matrix[m1, m2] <- co_occurrence_matrix[m1, m2] + 1
          co_occurrence_matrix[m2, m1] <- co_occurrence_matrix[m2, m1] + 1
        }

      }
      
      ms[, peak := peak]
      ds <- rbindlist(list(ds, ms), use.names = TRUE, fill = TRUE)
    }
    
  }

  return(list(co_occurrence_matrix, ds))
}
```

We can calculate co-occurence of all pairs of motifs without checking for overlaps. This is faster but not entirely accurate.

```{r}
mta_novl_dt <- readRDS( 
  file.path(syn_dir, sprintf("motif-hits-novl-%s-mona-q-%s.rds", arc_id, q))
)
mta_novl_counts <- count_co_occurrences(mta_novl_dt) # not checking overlap
saveRDS(
  mta_novl_counts, 
  file.path(syn_dir, sprintf("motif-co-occurrences-%s-mona-q-%s.rds", arc_id, q))
)
```

Alternatively, we can check co-occurence of motifs that don't overlap - this is slow so we run it on peaks split in bins, as a job array on custer.

```{r}
#| label: Co-occurence enrichment binned
#| eval: FALSE

# split peaks in bins
pks <- sort(unique(mta_novl_dt$peak))
pks_list <- sapply(split(pks, ceiling(seq_along(pks) / 1000)), function(x) x)
for (i in seq_along(pks_list)) {
  writeLines(pks_list[[i]], file.path(syn_dir, "bins", sprintf("peaks-%s.txt", i)))
}

# co-occurnece while checking overlap
# run script on bins of peaks (on HPC)
system("sbatch ./10_Motif_syntax_co-occurrence.sh")
```

Parse counts for co-occurnece of motifs that don't overlap.

```{r}
# Load results of binned analysis
res_fns <- list.files(file.path(syn_dir, "bins"), pattern = "co-occurrences-.*.rds", full.names = TRUE)
res_lst <- lapply(res_fns, function(x) {
  message(sprintf("(%d/%d) %s", which(res_fns == x), length(res_fns), x))
  readRDS(x)[[2]][nonoverlapping == TRUE]
})
mta_pair_novl_dt <- rbindlist(res_lst)

# Save co-occurences
saveRDS(
  mta_pair_novl_dt, 
  file.path(syn_dir, sprintf(
    "motif-co-occurrences-nonovl-%s-mona-q-%s.rds", 
    arc_id, q
  ))
)

# Save co-occurence counts
mta_pair_novl_count_dt <- mta_pair_novl_dt[, .N, .(motif1, motif2)]
fwrite(
  mta_pair_novl_count_dt, 
  file.path(syn_dir, sprintf(
    "motif-co-occurrences-nonovl-%s-mona-q-%s-counts.tsv.gz", 
    arc_id, q
  ))
)

```

Annotate co-occurences for motifs assigned to TFs.

```{r}
# Motifs assigned to TFs
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
q <- 0.95
mta_pair_novl_dt <- readRDS(file.path(syn_dir, sprintf(
  "motif-co-occurrences-nonovl-%s-mona-q-%s.rds", 
  arc_id, q
)))
assign_dt <- fread(file.path(
  "results", "Motifs",
  sprintf("motif-assignment-archetypes-%s.tsv.gz", arc_id)
))
assign_dt <- assign_dt[, .(archetype_name, gene, gene_name, og, common_name, tf_family)]
assign_dt[common_name != "", gene_name := common_name][, common_name := NULL]
assign_dt[gene_name == "", gene_name := ifelse(nchar(og) > 40, paste0(substr(og, 1, 37), "..."), og)][, og := NULL]

# Combine rows for same motif with ,
assign_dt <- assign_dt[, lapply(.SD, paste, collapse = ";"), .SDcols = c("gene", "gene_name", "tf_family"), by = archetype_name]

# Combine with motifs pairs data
setnames(mta_pair_novl_dt, c("m1", "m2"), c("motif1", "motif2"))
setnames(assign_dt, c("motif1", "gene_motif1", "gene_name_motif1", "tf_family_motif1"))
mta_pair_novl_gen_1 <- merge.data.table(
  mta_pair_novl_dt, assign_dt, by = "motif1", allow.cartesian = TRUE
)
setnames(assign_dt, c("motif2", "gene_motif2", "gene_name_motif2", "tf_family_motif2"))
mta_pair_novl_gen <- merge.data.table(
  mta_pair_novl_gen_1, assign_dt, by = "motif2", allow.cartesian = TRUE
)
mta_pair_novl_gen[, gene_pair := sprintf("%s + %s", gene_name_motif1, gene_name_motif2)]

# Save gene annotated non-overlapping co-occurence pairs
saveRDS(
  mta_pair_novl_gen, 
  file.path(syn_dir, sprintf(
    "motif-co-occurrences-nonovl-%s-mona-q-%s-TFs.rds", 
    arc_id, q
  ))
)

```

## Motif co-occurance in cell type peaks

Of all the possible non-overlapping motif hits, we will focus on the ones enriched in each cell type.

```{r}
# load enriched motifs per cell type
mta_enr_ls <- lapply(c(
  file.path(mta_dir, sprintf("motif-enrichment-cell-type-mona-q%s.tsv.gz", q)),
  file.path(arc_dir, sprintf("motif-enrichment-cell-type-archetypes-%s-mona-q%s.tsv.gz", arc_id, q))
), fread)
mta_enr_dt <- rbindlist(mta_enr_ls)

# save
saveRDS(
  mta_enr_dt, 
  file.path(syn_dir, sprintf(
    "motif-enrichment-cell-type-%s-mona-q-%s-enr.rds", 
    arc_id, q
  ))
)
```

We parse cell type peak annotation.

```{r}
# load peaks cell type annotation
pks_aces_dt <- fread(file.path(pks_dir, "Peaks_per_cell_type_mapped.tsv.gz")) 
pks_diff_dt <- fread(file.path(pks_dir, "Peaks_per_cell_type_differential_mapped.tsv.gz"))
pks_annt_dt <- merge.data.table(
  pks_aces_dt[, .(peak, cell_type)], 
  pks_diff_dt[, .(peak, Log2FC, Pval, FDR, cell_type)],
  by = c("peak", "cell_type"),
  all = TRUE
)
pks_annt_dt[is.na(Log2FC), Log2FC := 0]
pks_annt_dt[is.na(Pval), Pval := 1]
pks_annt_dt[is.na(FDR), FDR := 1]

saveRDS(
  pks_annt_dt, 
  file.path(syn_dir, "peaks-per-cell-type-annotation.rds")
)
```

We can now select peaks with different level of cell type specificity.

```{r}
# load peaks cell type annotation
pks_annt_dt <- readRDS(file.path(syn_dir, "peaks-per-cell-type-annotation.rds"))

# use all peaks
pks_dt <- copy(pks_annt_dt)

# alternatively, use differential peaks
pks_log2fc_thr <- 1
pks_fdr_thr <- 1
pks_dt <- pks_annt_dt[!(FDR > pks_fdr_thr) & !(Log2FC < pks_log2fc_thr)]

# count peaks
pks_num <- pks_dt[, .(n_peaks = .N), cell_type]

# only consider cell types with sufficient peaks
#cell_types_sub <- pks_num[n_peaks > 100]$cell_type
#pks_num <- pks_num[cell_type %in% cell_types_sub]
```

Now we will get counts for pairs of co-occuring motifs in selected cell type (differential) peaks.

```{r}
# load motif enrichments
mta_enr_dt <- readRDS(
  file.path(syn_dir, sprintf(
    "motif-enrichment-cell-type-%s-mona-q-%s-enr.rds", 
    arc_id, q
  ))
)

# get significant enriched motifs per cell type
mta_log2fc_thr <- 1
mta_padj_thr <- 0.05
mta_enr_sig <- mta_enr_dt[!(padj > mta_padj_thr) & !(log2(fc) < mta_log2fc_thr)]

# count motifs
mta_num <- mta_enr_sig[, .(n_motifs = .N), cell_type]

# load data for co-occurence of motifs assigned to TFs
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
q <- 0.95
mta_pair_novl_gen <- readRDS(file.path(
  syn_dir, sprintf(
    "motif-co-occurrences-nonovl-%s-mona-q-%s-TFs.rds",
    arc_id, q
  )
))

# subset motif occurence data for enriched motifs
mta_pair_novl_enr <- mta_pair_novl_gen[
  motif1 %in% mta_enr_sig$motif | 
  motif2 %in% mta_enr_sig$motif
]

# subset motif occurence data for hits in significant peaks
mta_pair_novl_pks <- merge.data.table(
  mta_pair_novl_enr, pks_dt, by = "peak",
  all = FALSE, allow.cartesian = TRUE
)

# count motif pairs in significan peaks per cell type
mta_pair_novl_sig <- mta_pair_novl_pks[, .(count_peak_pair = .N), .(
  cell_type, 
  motif1, motif2, 
  gene_motif1, gene_motif2, 
  gene_name_motif1, gene_name_motif2, 
  tf_family_motif1, tf_family_motif2
)]

# add number of significant peaks
mtd_cnt <- merge.data.table(mta_pair_novl_sig, pks_num, by = "cell_type")
mtd_cnt[, frac_peak_pair := count_peak_pair / n_peaks, by = 1:nrow(mtd_cnt)]

# add number of significant motifs
mtd_cnt <- merge.data.table(mtd_cnt, mta_num, by = "cell_type")

# add motif pair column
mtd_cnt[, motif_pair := sprintf("%s + %s", motif1, motif2), by = 1:nrow(mtd_cnt)]
mtd_cnt[, gene_pair := sprintf("%s + %s", gene_motif1, gene_motif2), by = 1:nrow(mtd_cnt)]
mtd_cnt[, gene_name_pair := sprintf("%s + %s", gene_name_motif1, gene_name_motif2), by = 1:nrow(mtd_cnt)]

# save
saveRDS(
  mtd_cnt, 
  file.path(syn_dir, sprintf(
    "motif-co-occurrences-nonovl-%s-mona-q-%s-TFs-enr-counts-pks.rds", 
    arc_id, q
  ))
)
```

Get top pairs of enriched motifs per cell type.

```{r}
# top enriched motifs per cell type
ct <- "cnidocyte"

# Select motif pairs
mta_pair_frac <- 0.005
mta_pair_count <- 50
mts <- mta_enr_sig[cell_type == ct]$motif
enr_mts <- unique(
  mtd_cnt[
    cell_type == ct &
    frac_peak_pair > mta_pair_frac &
    count_peak_pair > mta_pair_count &
    (motif1 %in% mts | motif2 %in% mts)
  ]$motif_pair
)

# Subset data for selected motifs
mtd_cta <- mtd_cnt[motif_pair %in% enr_mts]
    
# Order cell types
stopifnot(all(mtd_cta$cell_type %in% cell_types))
mtd_cta[, cell_type := factor(
  cell_type, levels = intersect(cell_types, unique(mtd_cta$cell_type))
)]
```

Reduce motif pairs redundancy by taking motif similarity into account.

```{r}
# load motif similarity
mta_sim <- readRDS(file.path(
  mta_dir, "motifs-similarity-PPM-PCC.rds"
))

# all motif pairs
mts <- unique(mtd_cta[, .(motif1, motif2, motif_pair)])

# matrix of motif pair similarity
pair_sim <- matrix(0, nrow = nrow(mts), ncol = nrow(mts), dimnames = list(mts$motif_pair, mts$motif_pair))
for (x in seq_along(mts$motif_pair)) {
  for (y in seq_along(mts$motif_pair)) {
    if (x > y) next
    i <- mts$motif_pair[x]
    j <- mts$motif_pair[y]
    m1_i <- mts[motif_pair == i]$motif1
    m2_i <- mts[motif_pair == i]$motif2
    m1_j <- mts[motif_pair == j]$motif1
    m2_j <- mts[motif_pair == j]$motif2
    sim1 <- mta_sim[m1_i, m1_j]
    sim2 <- mta_sim[m2_i, m2_j]
    min_sim <- min(sim1, sim2)
    pair_sim[x, y] <- min_sim
    pair_sim[y, x] <- min_sim
  }
}

# cluster similarity matrix
hclust_res <- stats::hclust(as.dist(1-pair_sim), method = "ward.D2")

pdf(file.path(fig_dir, sprintf("motif-pairs-sim-%s.pdf", ct)),height=14,width=26)
plot(hclust_res)
dev.off()

hclust_cls <- cutree(hclust_res, h=1-0.7)
pair_sim <- pair_sim[hclust_res$order, hclust_res$order]
motif_pair_lvl <- rownames(pair_sim)

# plot similarity matrix
require(ComplexHeatmap)
# heatmap of similarities
pms <- Heatmap(
  pmax(pair_sim, 0),
  col = colorRamp2(c(0, 0.5, 1), c("#fff5f0", "#fc9272", "#a50f15")),
  cluster_rows = FALSE, cluster_columns = FALSE, ,
  show_row_names = TRUE, show_column_names = TRUE,
  name = "Motif pair similarity"
)
# heatmap cluster annotation
pms <- pms + rowAnnotation(
  clust = as.factor(hclust_cls[rownames(pair_sim)]), 
  annotation_legend_param = list(title = "Motif pair cluster")
)
pdf(
  file.path(fig_dir, "motif-pair-similarity.pdf"),
  width = 18, height = 18
)
print(pms)
dev.off()

# order and clusters of motifs pairs
mtd_cta[, motif_pair := factor(motif_pair, levels = motif_pair_lvl)]
mtd_cta[, motif_pair_idx := as.integer(motif_pair)]
setorder(mtd_cta, motif_pair_idx)

# split clusters if tf family is different
mtd_cta[, motif_pair_clust := as.character(hclust_cls[as.character(motif_pair)])]
mtd_cta[, tf_family_motif1 := paste(unique(str_split(tf_family_motif1, ";")[[1]]), collapse = ","), by = .I]
mtd_cta[, tf_family_motif2 := paste(unique(str_split(tf_family_motif2, ";")[[1]]), collapse = ","), by = .I]
mtd_cta[, motif_pair_tf_family := paste(sort(c(.SD$tf_family_motif1, .SD$tf_family_motif2)), collapse = " + "), by = 1:nrow(mtd_cta)]
num_fam_clust <- unique(mtd_cta[, .(motif_pair_clust, motif_pair_tf_family)])[,.N,.(motif_pair_clust)]
if (any(num_fam_clust$N>1)) {
  mtd_cta[, motif_pair_clust := paste(as.character(motif_pair_clust), motif_pair_tf_family, sep = ": "), by = 1:nrow(mtd_cta)]
}
```

Plot barplots

```{r}
# get per cell type values
mtd_dt <- mtd_cta[cell_type == ct]
mtd_dt[, max_count_peak_pair := max(count_peak_pair), by = motif_pair_clust]
setorder(mtd_dt, -max_count_peak_pair)
mtd_dt[, motif_pair_clust := factor(motif_pair_clust, levels = rev(unique(mtd_dt$motif_pair_clust)))]
setorder(mtd_dt, motif_pair_clust, -count_peak_pair)
mtd_dt[, gene_name_pair := factor(gene_name_pair, levels = unique(mtd_dt$gene_name_pair))]

# barplot
mtd_gp <- ggplot(mtd_dt, aes(count_peak_pair, gene_name_pair)) +
  geom_bar(stat = "identity") +
  scale_x_continuous(
    expand = expansion(mult = c(0, 0.05))
  ) +
  geom_text(aes(label = count_peak_pair), hjust = 1, color = "white") +
  scale_y_discrete(
    breaks = mtd_dt$gene_name_pair,
    labels = sapply(mtd_dt$gene_name_pair, function(x) {
      paste(
        str_trunc(str_split(as.character(x), " \\+ ")[[1]][1], width = 80),
        " + ",
        str_trunc(str_split(as.character(x), " \\+ ")[[1]][2], width = 80),
        sep = "", collapse = ""
      )
    })
  ) +
  ggforce::facet_col(motif_pair_clust~., scales = "free_y", space = "free") +
  theme(
    panel.grid.major.x = element_line(color = "grey", size = 0.5)
  )

# motifs
pwms <- readRDS(file.path(mta_dir, "motifs.rds"))
pairs_logo <- list()
for (pair in unique(mtd_dt$gene_name_pair)) {
  m1 <- mtd_dt[gene_name_pair == pair]$motif1[1]
  m2 <- mtd_dt[gene_name_pair == pair]$motif2[1]
  g1 <- mtd_dt[gene_name_pair == pair]$gene_name_motif1[1]
  g2 <- mtd_dt[gene_name_pair == pair]$gene_name_motif2[1]
  g1 <- ggseqlogo(pwms[[m1]]@motif) + theme_void() + labs(title = str_trunc(g1, width = 20))
  g2 <- ggseqlogo(pwms[[m2]]@motif) + theme_void() + labs(title = str_trunc(g2, width = 20))
  pairs_logo[[pair]] <- g1 + g2 + plot_layout(ncol = 2)
}
pairs_logo_patch <- wrap_plots(pairs_logo, ncol = 1)

gp <- mtd_gp + pairs_logo_patch + plot_layout(ncol = 2, widths = c(1, 1))
ggsave(
  file.path(fig_dir, sprintf("motif-co-occurrence-pairs-%s.pdf", ct)),
  gp, width = 28, height = 76, limitsize = FALSE
)
```

Compare to gkmSVM

```{r}
get_gi <- function(x) {
  tryCatch({
    structure(
        gnan[common_name == x]$gene, 
        names = x
      )
  }, error = function(e) {
    message(e)
    return(NA)
  })
}
pairs <- list(
  c(
    get_gi("ZNF845"),
    get_gi("SoxB2/Sox3")
  ),
  c(
    get_gi("Pou4"),
    get_gi("SoxB2/Sox3")
  ),
  c(
    get_gi("Pou4"),
    get_gi("ZNF845")
  ),
  c(
    get_gi("ZNF845"),
    get_gi("Cnido-Jun")
  ),
  c(
    get_gi("ZNF845"),
    get_gi("Cnido-Fos1")
  ),
  c(
    get_gi("Pou4"),
    get_gi("Cnido-Fos1")
  ),
  c(
    get_gi("SoxB2/Sox3"),
    get_gi("Cnido-Fos1")
  ),
)
gns <- c(
  "Pou4", "ZNF845", "PaxA", "SoxB2/Sox3", "Cnido-Fos1", "Cnido-Jun", "Prdm14d"
)
gns_pairs <- CJ(g1 = gns, g2 = gns)[g1 != g2]
pairs <- lapply(seq_len(nrow(gns_pairs)), function(i) {
  print(sprintf("%s + %s", gns_pairs$g1[i], gns_pairs$g2[i]))
  pairs[[i]] <- c(
    get_gi(gns_pairs$g1[i]),
    get_gi(gns_pairs$g2[i])
  )
})
pairs_hits <- lapply(pairs, function(pair) {

  i <- names(pair)[1]
  j <- names(pair)[2]
  
  x <- pair[1]
  y <- pair[2]
  
  unique(mtd_gp[(
    (grepl(x, gene_pair) | grepl(i, gene_name_pair)) & 
    (grepl(y, gene_pair) | grepl(j, gene_name_pair))
  )])[, pair := paste(i, j, sep = " + ")]

})

pairs_hits_dt <- rbindlist(pairs_hits)


# fractions in a cell type
ct <- "cnidocyte"
pct_dt <- pairs_hits_dt[cell_type == ct][order(count_peak_pair)]
pct_dt[, pair := factor(pair, levels = pct_dt$pair)]
gpb <- ggplot(pct_dt, aes(y = pair, x = count_peak_pair)) +
  geom_bar(stat = "identity", fill = ct_cols[ct]) +
  scale_x_continuous(
    expand = expansion(mult = c(0, 0.05)),
    sec.axis = sec_axis(
      trans = ~ . / unique(pct_dt$n_peaks) * 100,
      name = "Fraction of peaks with both motifs"
    )
  ) +
  labs(x = "Count of peaks with both motifs")
# save
ggsave(
  file.path(fig_dir, sprintf("motif-co-occurrence-%s-gkSVM-pairs-%s.pdf", mta_pair_frac, ct)),
  gpb, width = 8, height = 3
)

# cell type barplots
gps <- ggplot(pairs_hits_dt, aes(
    x = cell_type, 
    y = frac_peak_pair, 
    fill = cell_type
  )) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = ct_cols) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  facet_wrap(pair~., scales = "free_y", ncol = 1) +
  labs(y = "fraction of peaks with both motifs") +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.y = element_text(),
    axis.title.x = element_blank(),
    legend.position = "none"
  )

# save
ggsave(
  file.path(fig_dir, sprintf("motif-co-occurrence-%s-gkSVM-pairs-%s.pdf", mta_pair_frac, ct)),
  gps, width = 12, height = 12
)
```

## Motif co-occurence enrichment

Co-occurence enrichment in per cell type-specific peaks:
the fraction of peaks with hits of both motif1 and motif2
/ 
fractions of peaks with motif1 hits * fraction of peaks with motif2 hits

```{r}
# Archetype motifs to use
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
q <- 0.95

# Motif counts
mta_novl_dt <- readRDS(
  file.path(syn_dir, sprintf(
    "motif-hits-novl-%s-mona-q-%s.rds", 
    arc_id, q
  ))
)

# Motif pair counts
mta_pair_novl_dt <- readRDS(
  file.path(syn_dir, sprintf(
    "motif-co-occurrences-nonovl-%s-mona-q-%s.rds", 
    arc_id, q
  ))
)

# Motif similarities
sim_mat <- readRDS(
  file.path(mta_dir, "motif-archetypes-all-similarity-PPM-PCC.rds")
)

# All peaks
pks_dt <- fread(file.path(pks_dir, "Peaks_cell_type_mapped.tsv.gz"))

# Peaks per broad cell type
# pks_dt <- fread(file.path(pks_dir, "Peaks_cell_type_mapped_cell_type_assignment.tsv.gz"))

# Where to save the results
lvl <- "broad_cell_type"
cts <- unique(pks_dt[[lvl]])

lvl <- "cell_type"
cts <- names(ct_cols)

lvl <- "cell_type_differential"
cts <- names(ct_cols)

dir.create(file.path(syn_dir, lvl), showWarnings = FALSE)

# Count motif pairs in cell type peaks
for (ct in cts) {

  pks_ct_peaks <- tryCatch({
      
    pks_ct <- fread(file.path(pks_dir, sprintf("Peaks_per_%s_mapped.tsv.gz", lvl)))
    pks_ct_peaks <- pks_ct$peak

  }, error = function(e) {
    warning(sprintf("Error: %s", e$message))
    return(NULL)
  })

  if (!is.null(pks_ct_peaks)) {
    
    # Motif counts in selected peaks
    mta_novl_ct <- mta_novl_dt[peak %in% pks_ct_peaks]
    n_peaks <- length(unique(mta_novl_ct$peak))
    message(sprintf("%d %s peaks", n_peaks, ct))

    # Fraction of peaks with hits to each motif
    mta_novl_ct <- mta_novl_ct[, .(count_peak = length(unique(peak))), by = motif]
    mta_novl_ct[, frac_peak := count_peak / n_peaks, by = motif]
    setorder(mta_novl_ct, -frac_peak)

    # Motif pair counts in selected peaks
    mta_pair_novl_ct <- mta_pair_novl_dt[peak %in% pks_ct_peaks]
    mta_pair_novl_ct <- mta_pair_novl_ct[, .N, .(m1, m2)]
    
    # Fraction of peaks with hits to both motifs
    mta_pair_novl_ct[, frac_peak_pair := N / n_peaks, by = .(m1, m2)]
    setnames(mta_pair_novl_ct, c("m1", "m2", "N"), c("motif1", "motif2", "count_peak_pair"))

    # Add counts for individual motifs
    setnames(
      mta_novl_ct,
      c("motif1", "count_peak_motif1", "frac_peak_motif1")
    )
    mta_pair_novl_ct <- merge.data.table(
      mta_pair_novl_ct, mta_novl_ct, by = "motif1", all.x = TRUE
    )
    setnames(
      mta_novl_ct, 
      c("motif2", "count_peak_motif2", "frac_peak_motif2")
    )
    mta_pair_novl_ct <- merge.data.table(
      mta_pair_novl_ct, mta_novl_ct, by = "motif2", all.x = TRUE
    )
    setorder(mta_pair_novl_ct, -frac_peak_pair)
    setcolorder(mta_pair_novl_ct,c("motif1","motif2"))

    # Compute the enrichment
    mta_pair_novl_ct[, enrichment := frac_peak_pair / (frac_peak_motif1 * frac_peak_motif2), by = .I]

    # For motifs with less than 2 hits, set enrichment to 1
    mta_pair_novl_ct[count_peak_pair <= 2, enrichment := 1]

    # Motif pairs similarity
    mta_pair_novl_ct[, motifs_similarity := sim_mat[motif1, motif2], by = .(motif1, motif2)]

    # Report number of significant pairs
    message(
      sprintf(
        "%d pairs of motifs with enrichment > 2 and fraction of peaks with hits to both motifs > 1%%", 
        nrow(mta_pair_novl_ct[enrichment > 2 & frac_peak_pair > 0.01])
      )
    )
    
    # Save
    fwrite(
      mta_pair_novl_ct, 
      file.path(syn_dir, lvl, sprintf(
        "motif-co-occurrences-enrichment-%s-%s-mona-q-%s.tsv.gz", 
        ct, arc_id, q
      ))
    )
     
  }
}

# Load co-occurence enrichment in all cell types
cts <- names(ct_cols)
enr_dt <- rbindlist(lapply(cts, function(ct) {
  message(ct)
  mta_enr <- fread(
      file.path(syn_dir, lvl, sprintf(
          "motif-co-occurrences-enrichment-%s-%s-mona-q-%s.tsv.gz",
          ct, arc_id, q
      ))
  )
  mta_enr[, cell_type := ct]
}))

# Save all data
saveRDS(
    enr_dt,
    file.path(syn_dir, lvl, sprintf(
        "motif-co-occurrences-enrichment-%s-mona-q-%s.rds",
        arc_id, q
    ))
)

# Annotate
enr_dt[, log_enrichment := log2(enrichment)]
enr_dt[, motif_pair := sprintf("%s + %s", motif1, motif2)]
    
# Add 0s for missing cell types
all_combinations <- CJ(
  motif_pair = unique(enr_dt$motif_pair),
  cell_type = unique(enr_dt$cell_type)
)

# Join with the original data.table
dt <- merge(
  all_combinations, enr_dt,
  by = c("motif_pair", "cell_type"),
  all.x = TRUE
)
dt[is.na(motif1), "motif1" := str_split(motif_pair, " \\+ ")[[1]][1], by = .I]
dt[is.na(motif2), "motif2" := str_split(motif_pair, " \\+ ")[[1]][2], by = .I]
dt[is.na(dt)] <- 0

# Motifs assigned to TFs
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
assign_dt <- fread(file.path(
  "results", "Motifs",
  sprintf("motif-assignment-archetypes-%s.tsv.gz", arc_id)
))

assign_dt <- assign_dt[, .(archetype_name, gene, gene_name, og, common_name, tf_family)]
assign_dt[common_name != "", gene_name := common_name][, common_name := NULL]
assign_dt[gene_name == "", gene_name := ifelse(nchar(og) > 40, paste0(substr(og, 1, 37), "..."), og)][, og := NULL]

# Combine rows for same motif with ,
assign_dt <- assign_dt[, lapply(.SD, paste, collapse = ";"), .SDcols = c("gene", "gene_name", "tf_family"), by = archetype_name]

# Combine with motifs pairs data
setnames(assign_dt, c("motif1", "gene_motif1", "gene_name_motif1", "tf_family_motif1"))
mta_enr_gen <- merge.data.table(dt, assign_dt, by = "motif1", allow.cartesian = TRUE)
setnames(assign_dt, c("motif2", "gene_motif2", "gene_name_motif2", "tf_family_motif2"))
mta_enr_gen <- merge.data.table(mta_enr_gen, assign_dt, by = "motif2", allow.cartesian = TRUE)
mta_enr_gen[, gene_pair := sprintf("%s + %s", gene_name_motif1, gene_name_motif2)]

# save data for shiny app
saveRDS(
  mta_enr_gen, 
  file.path(syn_dir, lvl, "motif-co-occurrences-enrichment.rds")
)
```

Inspect the results

```{r}
# Archetype motifs used
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
q <- 0.95

# Cell type
lvl <- "cell_type"
ct <- "cnidocyte"

# Co-occurence nerichment
mta_enr <- fread(
  file.path(syn_dir, lvl, sprintf(
    "motif-co-occurrences-enrichment-%s-%s-mona-q-%s.tsv.gz", 
    ct, arc_id, q
  ))
)
mta_enr[, log_enrichment := log2(enrichment)]
mta_enr[, motif_pair := sprintf("%s + %s", motif1, motif2)]

# Motifs assigned to TFs
arc_id <- "PPM-PCC-0.8-IC0.5-5bp"
assign_dt <- fread(file.path(
  "results", "Motifs",
  sprintf("motif-assignment-archetypes-%s.tsv.gz", arc_id)
))

assign_dt <- assign_dt[, .(archetype_name, gene, gene_name, og, common_name, tf_family)]
assign_dt[common_name != "", gene_name := common_name][, common_name := NULL]
assign_dt[gene_name == "", gene_name := ifelse(nchar(og) > 40, paste0(substr(og, 1, 37), "..."), og)][, og := NULL]

# Combine rows for same motif with ,
assign_dt <- assign_dt[, lapply(.SD, paste, collapse = ";"), .SDcols = c("gene", "gene_name", "tf_family"), by = archetype_name]

# Combine with motifs pairs data
mta_enr_gen <- copy(mta_enr)
setnames(assign_dt, c("motif1", "gene_motif1", "gene_name_motif1", "tf_family_motif1"))
mta_enr_gen <- merge.data.table(mta_enr_gen, assign_dt, by = "motif1", allow.cartesian = TRUE)
setnames(assign_dt, c("motif2", "gene_motif2", "gene_name_motif2", "tf_family_motif2"))
mta_enr_gen <- merge.data.table(mta_enr_gen, assign_dt, by = "motif2", allow.cartesian = TRUE)
mta_enr_gen[, gene_pair := sprintf("%s + %s", gene_name_motif1, gene_name_motif2)]

# Filter pairs to plot
mta_enr_gp <- mta_enr_gen[frac_peak_pair > 0.01]

# Motif logos
# mta_pwm <- read_meme(file.path(mta_dir, "motif-archetypes-all.meme"))
# names(mta_pwm) <- sapply(mta_pwm, function(m) m@name)

# Plot
gp_enr <- ggplot(mta_enr_gp, aes(count_peak_pair, enrichment)) +
  geom_point() +
  #geom_text_repel(
  #  data = mta_enr_gp[(enrichment > 1.25)],
  #  aes(label = gene_pair), max.overlaps = Inf, size = 2
  #) +
  scale_x_continuous(trans = "log10") +
  scale_y_continuous(trans = "log2") +
  labs(
    x = "Peaks with motif co-occurrence",
    y = "Co-occurence enrichment"
  ) +
  theme(
    panel.grid.major = element_line(color = "grey", linewidth = 0.2),
    panel.grid.minor = element_line(color = "grey", linewidth = 0.2)
  )
ggsave(file.path(
  fig_dir, sprintf("motif-co-occurrence-enrichment-%s-%s-mona-q-%s.pdf", ct, arc_id, q)
), gp_enr, width = 14, height = 14)

```

Interactive plotly plot

```{r}
require(ggplot2)
require(plotly)
require(data.table)

# Prepare ggplot
gp_enr <- ggplot(mta_enr_gp, aes(count_peak_pair, enrichment, text = gene_pair)) +
  geom_point(aes(text = sprintf(
    "Gene Pair: %s
    Motif1: %s
    Motif2: %s",
    gene_pair, gene_name_motif1, gene_name_motif2
  ))) +
  scale_x_continuous(trans = "log10") +
  scale_y_continuous(trans = "log2") +
  labs(
    x = "Peaks with motif co-occurrence",
    y = "Co-occurence enrichment"
  ) +
  theme_minimal()

# Convert ggplot to plotly
plotly_enr <- ggplotly(gp_enr, tooltip = "text")

# Save the plotly object as an HTML file
require(htmlwidgets)
html_file <- file.path(fig_dir, sprintf("motif-co-occurrence-enrichment-%s-%s-mona-q-%s.html", ct, arc_id, q))
saveWidget(plotly_enr, file = html_file, selfcontained = TRUE)

```

Plot heatmap of motif pair co-occurnece enrichment in cell types

```{r}
# Filter pairs to plot
enr_mts <- unique(
  mta_enr_gen[frac_peak_pair > 0.025 & enrichment > 2]$motif_pair
)
mta_enr_gp <- mta_enr_gen[motif_pair %in% enr_mts]

# Order pairs
stopifnot(all(mta_enr_gp$cell_type %in% cts))
mta_enr_gp[, cell_type := factor(cell_type, levels = cts)]
mta_enr_gp[order(motif_pair, -enrichment), max_enr_ct := as.integer(.SD[1]$cell_type), motif_pair]
setorder(mta_enr_gp, max_enr_ct, -enrichment, motif_pair)
mta_enr_gp[, motif_pair := factor(motif_pair, levels = unique(mta_enr_gp$motif_pair))]
mta_enr_gp[, gene_pair := factor(gene_pair, levels = unique(mta_enr_gp$gene_pair))]

# Ranges for plotting
mta_enr_gp[, log_enrichment := pmax(log_enrichment, 0)]
mta_enr_gp[, log_enrichment := pmin(log_enrichment, 2)]

# Plot heatmap
gp_enr <- ggplot(mta_enr_gp, aes(cell_type, gene_pair, fill = log_enrichment)) +
  geom_tile() +
  scale_fill_gradient2(
    low = "blue", mid = "white", high = "red", midpoint = 1
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  labs(
    y = sprintf("%s motif pairs", length(unique(mta_enr_gp$gene_pair))),
  )

# Plot tf family annotation bar
mta_ann_gp <- unique(mta_enr_gp[, .(gene_pair, tf_family_motif1, tf_family_motif2)])
mta_ann_gp <- melt.data.table(mta_ann_gp, id.vars = "gene_pair")
mta_ann_gp[, value := paste(unique(str_split(value, ";")[[1]]), collapse = ","), by = .I]
n_fams <- length(unique(mta_ann_gp$value))
custom_palette <- scales::hue_pal()(n_fams)
custom_palette <- colorRampPalette(brewer.pal(12, "Paired"))(n_fams)
gp_fam <- ggplot(mta_ann_gp, aes(variable, gene_pair, fill = value)) +
  geom_tile(width = 1) +
  theme_minimal() +
  scale_fill_manual(values = custom_palette) +
  #scale_fill_viridis_d(option = "C") +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    axis.text.y = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "right",
    legend.box = "vertical"
  ) +
  guides(fill = guide_legend(ncol = 1))

# Combine plot and annotation
require(patchwork)
gp_enr_ann <- gp_enr + gp_fam + plot_layout(ncol = 2, widths = c(10, 1), guides = "collect") 

# Save
ggsave(file.path(
  fig_dir, sprintf("motif-co-occurrence-enrichment-heatmap-%s-mona-q-%s.pdf", arc_id, q)
), gp_enr_ann, width = 7, height = 24)
```

Interactive plot

```{r}
# Plot heatmap
gp_enr <- ggplot(mta_enr_gp, aes(gene_pair, cell_type, fill = log_enrichment)) +
  geom_tile() +
  geom_tile(aes(text = sprintf(
    "Gene Pair: %s
    Cell type: %s
    Enrichment: %.2f",
    gene_pair, cell_type, log_enrichment
  ))) +
  scale_fill_gradient2(
    low = "blue", mid = "white", high = "red", midpoint = 1
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(angle = 90, hjust = 1),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  labs(
    x = sprintf("%s motif pairs", length(unique(mta_enr_gp$gene_pair))),
  )


# Convert ggplot to plotly
plotly_enr <- ggplotly(gp_enr, tooltip = "text")

# Save the plotly object as an HTML file
require(htmlwidgets)
html_file <- file.path(fig_dir, sprintf("motif-co-occurrence-enrichment-heatmap-%s-mona-q-%s.html", arc_id, q))
saveWidget(plotly_enr, file = html_file, selfcontained = TRUE)

# this is messed up
```
